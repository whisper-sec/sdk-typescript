/* tslint:disable */
/* eslint-disable */
/**
 * Whisper API Platform
 * Whisper provides comprehensive intelligence and monitoring capabilities for domains, IPs, and web infrastructure. Access powerful APIs for WHOIS data, DNS analysis, screenshot capture, network intelligence, and more - all through a unified, authenticated interface.  **Key Features:** â€¢ Domain intelligence and subdomain discovery â€¢ IP geolocation and network analysis â€¢ Real-time and historical WHOIS data â€¢ Automated website screenshot capture â€¢ Network relationship mapping â€¢ BGP routing and security intelligence â€¢ Infrastructure monitoring and health checks  **Authentication:** All endpoints require Bearer token authentication. Contact support for API access.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@whisper.security
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Comprehensive domain intelligence response containing registration, DNS, relationships, and IP data
 * @export
 * @interface DomainIntelligenceResponse
 */
export interface DomainIntelligenceResponse {
    /**
     * 
     * @type {DomainIntelligenceResponseQuery}
     * @memberof DomainIntelligenceResponse
     */
    'query'?: DomainIntelligenceResponseQuery;
    /**
     * 
     * @type {DomainIntelligenceResponseSummary}
     * @memberof DomainIntelligenceResponse
     */
    'summary'?: DomainIntelligenceResponseSummary;
    /**
     * WHOIS registration details
     * @type {object}
     * @memberof DomainIntelligenceResponse
     */
    'registration'?: object;
    /**
     * DNS records (A, AAAA, MX, NS, TXT, etc.)
     * @type {object}
     * @memberof DomainIntelligenceResponse
     */
    'dns'?: object;
    /**
     * Related domains and infrastructure
     * @type {object}
     * @memberof DomainIntelligenceResponse
     */
    'relationships'?: object;
    /**
     * Trademark information
     * @type {object}
     * @memberof DomainIntelligenceResponse
     */
    'trademark'?: object;
    /**
     * Intelligence for resolved IP addresses
     * @type {object}
     * @memberof DomainIntelligenceResponse
     */
    'ip_intelligence'?: object;
    /**
     * Response metadata and data sources
     * @type {object}
     * @memberof DomainIntelligenceResponse
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface DomainIntelligenceResponseQuery
 */
export interface DomainIntelligenceResponseQuery {
    /**
     * Queried domain
     * @type {string}
     * @memberof DomainIntelligenceResponseQuery
     */
    'domain'?: string;
    /**
     * Query timestamp
     * @type {string}
     * @memberof DomainIntelligenceResponseQuery
     */
    'timestamp'?: string;
    /**
     * Response time in milliseconds
     * @type {number}
     * @memberof DomainIntelligenceResponseQuery
     */
    'response_time_ms'?: number;
}
/**
 * 
 * @export
 * @interface DomainIntelligenceResponseSummary
 */
export interface DomainIntelligenceResponseSummary {
    /**
     * Domain name
     * @type {string}
     * @memberof DomainIntelligenceResponseSummary
     */
    'domain_name'?: string;
    /**
     * Domain registrar
     * @type {string}
     * @memberof DomainIntelligenceResponseSummary
     */
    'registrar'?: string;
    /**
     * Registration date
     * @type {string}
     * @memberof DomainIntelligenceResponseSummary
     */
    'registration_date'?: string;
    /**
     * Expiration date
     * @type {string}
     * @memberof DomainIntelligenceResponseSummary
     */
    'expiration_date'?: string;
    /**
     * Domain status
     * @type {string}
     * @memberof DomainIntelligenceResponseSummary
     */
    'status'?: string;
    /**
     * Trademark status
     * @type {boolean}
     * @memberof DomainIntelligenceResponseSummary
     */
    'has_trademark'?: boolean;
    /**
     * Primary DNS provider
     * @type {string}
     * @memberof DomainIntelligenceResponseSummary
     */
    'dns_provider'?: string;
    /**
     * Incoming links
     * @type {number}
     * @memberof DomainIntelligenceResponseSummary
     */
    'total_links_in'?: number;
    /**
     * Outgoing links
     * @type {number}
     * @memberof DomainIntelligenceResponseSummary
     */
    'total_links_out'?: number;
}
/**
 * Parameters for an asynchronous domain search (either similarity or free-text)
 * @export
 * @interface DomainerAsyncRequestDTO
 */
export interface DomainerAsyncRequestDTO {
    /**
     * (Required for SIMILARITY requests) Domain name to search for similar domains
     * @type {string}
     * @memberof DomainerAsyncRequestDTO
     */
    'domainName'?: string;
    /**
     * (Required for SIMILARITY requests) Type of similarity to use: CONTAINS, SOUNDING, PREFIX, SUFFIX, TYPO, UTFVARS
     * @type {string}
     * @memberof DomainerAsyncRequestDTO
     */
    'similarityType'?: DomainerAsyncRequestDTOSimilarityTypeEnum;
    /**
     * (Required for SEARCH requests) Query string (supports standard query syntax)
     * @type {string}
     * @memberof DomainerAsyncRequestDTO
     */
    'queryString'?: string;
    /**
     * (Optional for SEARCH requests) Default operator between query terms if not specified
     * @type {string}
     * @memberof DomainerAsyncRequestDTO
     */
    'operator'?: DomainerAsyncRequestDTOOperatorEnum;
    /**
     * (Optional for SEARCH requests) Filter results by absolute domain level (dot count)
     * @type {string}
     * @memberof DomainerAsyncRequestDTO
     */
    'level'?: DomainerAsyncRequestDTOLevelEnum;
    /**
     * Set to true to find AVAILABLE similar domains (typo/sounding) instead of existing ones. Requires domainName, ignores similarityType/queryString/operator/level.
     * @type {boolean}
     * @memberof DomainerAsyncRequestDTO
     */
    'findAvailable'?: boolean;
    /**
     * Maximum number of results to return (use a reasonable limit to prevent excessive processing)
     * @type {number}
     * @memberof DomainerAsyncRequestDTO
     */
    'limit'?: number;
    /**
     * URL to call with results when the search is complete (must be accessible from the server)
     * @type {string}
     * @memberof DomainerAsyncRequestDTO
     */
    'callbackUrl': string;
}

export const DomainerAsyncRequestDTOSimilarityTypeEnum = {
    Contains: 'CONTAINS',
    Prefix: 'PREFIX',
    Suffix: 'SUFFIX',
    Typo: 'TYPO',
    Sounding: 'SOUNDING',
    Utfvars: 'UTFVARS',
    TldVariants: 'TLD_VARIANTS',
    TypoOrSounding: 'TYPO_OR_SOUNDING',
    Levenshtein: 'LEVENSHTEIN',
    Contains2: 'CONTAINS',
    Sounding2: 'SOUNDING',
    Prefix2: 'PREFIX',
    Suffix2: 'SUFFIX',
    Typo2: 'TYPO',
    Utfvars2: 'UTFVARS'
} as const;

export type DomainerAsyncRequestDTOSimilarityTypeEnum = typeof DomainerAsyncRequestDTOSimilarityTypeEnum[keyof typeof DomainerAsyncRequestDTOSimilarityTypeEnum];
export const DomainerAsyncRequestDTOOperatorEnum = {
    And: 'AND',
    Or: 'OR'
} as const;

export type DomainerAsyncRequestDTOOperatorEnum = typeof DomainerAsyncRequestDTOOperatorEnum[keyof typeof DomainerAsyncRequestDTOOperatorEnum];
export const DomainerAsyncRequestDTOLevelEnum = {
    All: 'ALL',
    Immediate: 'IMMEDIATE',
    MaxDepth: 'MAX_DEPTH'
} as const;

export type DomainerAsyncRequestDTOLevelEnum = typeof DomainerAsyncRequestDTOLevelEnum[keyof typeof DomainerAsyncRequestDTOLevelEnum];

/**
 * Response object for an asynchronous domain similarity search request submission
 * @export
 * @interface DomainerAsyncResponseDTO
 */
export interface DomainerAsyncResponseDTO {
    /**
     * Unique identifier for tracking the request
     * @type {string}
     * @memberof DomainerAsyncResponseDTO
     */
    'requestId': string;
    /**
     * Domain name being searched
     * @type {string}
     * @memberof DomainerAsyncResponseDTO
     */
    'domainName': string;
    /**
     * Query string submitted for free-text search (if applicable)
     * @type {string}
     * @memberof DomainerAsyncResponseDTO
     */
    'queryString'?: string | null;
    /**
     * Status message providing information about the request
     * @type {string}
     * @memberof DomainerAsyncResponseDTO
     */
    'message': string;
    /**
     * URL to check for results (can be polled to monitor progress and get results)
     * @type {string}
     * @memberof DomainerAsyncResponseDTO
     */
    'statusUrl': string;
}
/**
 * Results and status information for an asynchronous domain search request (similarity or free-text)
 * @export
 * @interface DomainerAsyncResultDTO
 */
export interface DomainerAsyncResultDTO {
    /**
     * Unique identifier for the request
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'requestId': string;
    /**
     * Domain name that was searched
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'domainName'?: string;
    /**
     * 
     * @type {DomainerSimilarityType}
     * @memberof DomainerAsyncResultDTO
     */
    'similarityType'?: DomainerSimilarityType;
    /**
     * Query string used for the search (only for SEARCH requests)
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'queryString'?: string | null;
    /**
     * Default operator used between query terms (only for SEARCH requests)
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'operator'?: DomainerAsyncResultDTOOperatorEnum | null;
    /**
     * Absolute domain level filter applied (only for SEARCH requests)
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'level'?: DomainerAsyncResultDTOLevelEnum | null;
    /**
     * Maximum number of results requested
     * @type {number}
     * @memberof DomainerAsyncResultDTO
     */
    'limit': number;
    /**
     * Time when the request was created
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'createdAt': string;
    /**
     * Time when the request was completed (null if still processing)
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'completedAt'?: string | null;
    /**
     * Request status
     * @type {string}
     * @memberof DomainerAsyncResultDTO
     */
    'status': DomainerAsyncResultDTOStatusEnum;
    /**
     * List of similar domains found (null if still processing)
     * @type {Array<string>}
     * @memberof DomainerAsyncResultDTO
     */
    'results'?: Array<string> | null;
    /**
     * Total number of results found
     * @type {number}
     * @memberof DomainerAsyncResultDTO
     */
    'resultCount'?: number;
    /**
     * Time taken to process the request in milliseconds (-1 if still processing)
     * @type {number}
     * @memberof DomainerAsyncResultDTO
     */
    'processingTimeMs'?: number;
}

export const DomainerAsyncResultDTOOperatorEnum = {
    And: 'AND',
    Or: 'OR'
} as const;

export type DomainerAsyncResultDTOOperatorEnum = typeof DomainerAsyncResultDTOOperatorEnum[keyof typeof DomainerAsyncResultDTOOperatorEnum];
export const DomainerAsyncResultDTOLevelEnum = {
    All: 'ALL',
    Immediate: 'IMMEDIATE',
    MaxDepth: 'MAX_DEPTH'
} as const;

export type DomainerAsyncResultDTOLevelEnum = typeof DomainerAsyncResultDTOLevelEnum[keyof typeof DomainerAsyncResultDTOLevelEnum];
export const DomainerAsyncResultDTOStatusEnum = {
    Processing: 'PROCESSING',
    Completed: 'COMPLETED'
} as const;

export type DomainerAsyncResultDTOStatusEnum = typeof DomainerAsyncResultDTOStatusEnum[keyof typeof DomainerAsyncResultDTOStatusEnum];

/**
 * Type of similarity that was used for the search
 * @export
 * @enum {string}
 */

export const DomainerSimilarityType = {
    Contains: 'CONTAINS',
    Prefix: 'PREFIX',
    Suffix: 'SUFFIX',
    Typo: 'TYPO',
    Sounding: 'SOUNDING',
    Utfvars: 'UTFVARS',
    TldVariants: 'TLD_VARIANTS',
    TypoOrSounding: 'TYPO_OR_SOUNDING',
    Levenshtein: 'LEVENSHTEIN'
} as const;

export type DomainerSimilarityType = typeof DomainerSimilarityType[keyof typeof DomainerSimilarityType];


/**
 * Response containing a list of strings
 * @export
 * @interface DomainerStringListResponse
 */
export interface DomainerStringListResponse {
    /**
     * List of string results
     * @type {Array<string>}
     * @memberof DomainerStringListResponse
     */
    'results'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Error code for programmatic handling
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * Timestamp when the error occurred
     * @type {string}
     * @memberof ErrorResponse
     */
    'timestamp': string;
    /**
     * Request path that caused the error
     * @type {string}
     * @memberof ErrorResponse
     */
    'path'?: string;
}
/**
 * Comprehensive IP intelligence response containing geolocation, network, security, and relationship data
 * @export
 * @interface IpIntelligenceResponse
 */
export interface IpIntelligenceResponse {
    /**
     * 
     * @type {IpIntelligenceResponseQuery}
     * @memberof IpIntelligenceResponse
     */
    'query'?: IpIntelligenceResponseQuery;
    /**
     * 
     * @type {IpIntelligenceResponseSummary}
     * @memberof IpIntelligenceResponse
     */
    'summary'?: IpIntelligenceResponseSummary;
    /**
     * 
     * @type {IpIntelligenceResponseGeolocation}
     * @memberof IpIntelligenceResponse
     */
    'geolocation'?: IpIntelligenceResponseGeolocation;
    /**
     * Network and routing information
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'network'?: object;
    /**
     * ISP and organization details
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'isp'?: object;
    /**
     * DNS and infrastructure relationships
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'relationships'?: object;
    /**
     * Reputation and threat intelligence
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'reputation'?: object;
    /**
     * Security assessment and RPKI status
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'security'?: object;
    /**
     * IP validation details
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'validation'?: object;
    /**
     * Historical routing data
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'history'?: object;
    /**
     * ASN ownership and prefix details
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'asn_details'?: object;
    /**
     * Response metadata and data sources
     * @type {object}
     * @memberof IpIntelligenceResponse
     */
    'metadata'?: object;
}
/**
 * Geolocation data with confidence scores
 * @export
 * @interface IpIntelligenceResponseGeolocation
 */
export interface IpIntelligenceResponseGeolocation {
    /**
     * 
     * @type {IpIntelligenceResponseGeolocationCountry}
     * @memberof IpIntelligenceResponseGeolocation
     */
    'country'?: IpIntelligenceResponseGeolocationCountry;
    /**
     * 
     * @type {IpIntelligenceResponseGeolocationCoordinates}
     * @memberof IpIntelligenceResponseGeolocation
     */
    'coordinates'?: IpIntelligenceResponseGeolocationCoordinates;
}
/**
 * 
 * @export
 * @interface IpIntelligenceResponseGeolocationCoordinates
 */
export interface IpIntelligenceResponseGeolocationCoordinates {
    /**
     * Latitude
     * @type {number}
     * @memberof IpIntelligenceResponseGeolocationCoordinates
     */
    'latitude'?: number;
    /**
     * Longitude
     * @type {number}
     * @memberof IpIntelligenceResponseGeolocationCoordinates
     */
    'longitude'?: number;
    /**
     * Accuracy radius in kilometers
     * @type {number}
     * @memberof IpIntelligenceResponseGeolocationCoordinates
     */
    'accuracy_radius'?: number;
    /**
     * IANA time zone
     * @type {string}
     * @memberof IpIntelligenceResponseGeolocationCoordinates
     */
    'time_zone'?: string;
}
/**
 * 
 * @export
 * @interface IpIntelligenceResponseGeolocationCountry
 */
export interface IpIntelligenceResponseGeolocationCountry {
    /**
     * ISO 3166-1 alpha-2 code
     * @type {string}
     * @memberof IpIntelligenceResponseGeolocationCountry
     */
    'iso_code'?: string;
    /**
     * Country name
     * @type {string}
     * @memberof IpIntelligenceResponseGeolocationCountry
     */
    'name'?: string;
    /**
     * Confidence score (0-100)
     * @type {number}
     * @memberof IpIntelligenceResponseGeolocationCountry
     */
    'confidence'?: number;
}
/**
 * Query metadata
 * @export
 * @interface IpIntelligenceResponseQuery
 */
export interface IpIntelligenceResponseQuery {
    /**
     * Queried IP address
     * @type {string}
     * @memberof IpIntelligenceResponseQuery
     */
    'ip'?: string;
    /**
     * Query timestamp
     * @type {string}
     * @memberof IpIntelligenceResponseQuery
     */
    'timestamp'?: string;
    /**
     * Response time in milliseconds
     * @type {number}
     * @memberof IpIntelligenceResponseQuery
     */
    'response_time_ms'?: number;
}
/**
 * Executive summary of IP intelligence
 * @export
 * @interface IpIntelligenceResponseSummary
 */
export interface IpIntelligenceResponseSummary {
    /**
     * Organization name
     * @type {string}
     * @memberof IpIntelligenceResponseSummary
     */
    'organization'?: string;
    /**
     * Geographic location
     * @type {string}
     * @memberof IpIntelligenceResponseSummary
     */
    'location'?: string;
    /**
     * Network prefix
     * @type {string}
     * @memberof IpIntelligenceResponseSummary
     */
    'network'?: string;
    /**
     * Primary ASN
     * @type {string}
     * @memberof IpIntelligenceResponseSummary
     */
    'asn_primary'?: string;
    /**
     * Risk score (0-1)
     * @type {number}
     * @memberof IpIntelligenceResponseSummary
     */
    'risk_score'?: number;
    /**
     * IP type classification
     * @type {string}
     * @memberof IpIntelligenceResponseSummary
     */
    'ip_type'?: string;
    /**
     * Number of associated domains
     * @type {number}
     * @memberof IpIntelligenceResponseSummary
     */
    'total_domains'?: number;
    /**
     * Number of DNS records
     * @type {number}
     * @memberof IpIntelligenceResponseSummary
     */
    'total_dns_records'?: number;
}

/**
 * DomainManagementApi - axios parameter creator
 * @export
 */
export const DomainManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Finds domains that are subdomains of the given base domain (e.g., finding \'www.example.com\' for base \'example.com\'). Allows filtering by absolute domain level (dot count). NOTE: This differs from relative depth filtering.
         * @summary Find subdomains
         * @param {string} baseDomain Base domain name (e.g., example.com)
         * @param {number} [limit] Maximum number of results
         * @param {FindSubdomainsLevelEnum} [level] Level of subdomains to find relative to the base domain (ALL, IMMEDIATE&#x3D;one level deeper, MAX_DEPTH&#x3D;deepest found relative to base).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubdomains: async (baseDomain: string, limit?: number, level?: FindSubdomainsLevelEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseDomain' is not null or undefined
            assertParamExists('findSubdomains', 'baseDomain', baseDomain)
            const localVarPath = `/domainer/api/domains/subdomains/{baseDomain}`
                .replace(`{${"baseDomain"}}`, encodeURIComponent(String(baseDomain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainManagementApi - functional programming interface
 * @export
 */
export const DomainManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Finds domains that are subdomains of the given base domain (e.g., finding \'www.example.com\' for base \'example.com\'). Allows filtering by absolute domain level (dot count). NOTE: This differs from relative depth filtering.
         * @summary Find subdomains
         * @param {string} baseDomain Base domain name (e.g., example.com)
         * @param {number} [limit] Maximum number of results
         * @param {FindSubdomainsLevelEnum} [level] Level of subdomains to find relative to the base domain (ALL, IMMEDIATE&#x3D;one level deeper, MAX_DEPTH&#x3D;deepest found relative to base).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSubdomains(baseDomain: string, limit?: number, level?: FindSubdomainsLevelEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainerStringListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSubdomains(baseDomain, limit, level, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainManagementApi.findSubdomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainManagementApi - factory interface
 * @export
 */
export const DomainManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainManagementApiFp(configuration)
    return {
        /**
         * Finds domains that are subdomains of the given base domain (e.g., finding \'www.example.com\' for base \'example.com\'). Allows filtering by absolute domain level (dot count). NOTE: This differs from relative depth filtering.
         * @summary Find subdomains
         * @param {string} baseDomain Base domain name (e.g., example.com)
         * @param {number} [limit] Maximum number of results
         * @param {FindSubdomainsLevelEnum} [level] Level of subdomains to find relative to the base domain (ALL, IMMEDIATE&#x3D;one level deeper, MAX_DEPTH&#x3D;deepest found relative to base).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSubdomains(baseDomain: string, limit?: number, level?: FindSubdomainsLevelEnum, options?: RawAxiosRequestConfig): AxiosPromise<DomainerStringListResponse> {
            return localVarFp.findSubdomains(baseDomain, limit, level, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainManagementApi - object-oriented interface
 * @export
 * @class DomainManagementApi
 * @extends {BaseAPI}
 */
export class DomainManagementApi extends BaseAPI {
    /**
     * Finds domains that are subdomains of the given base domain (e.g., finding \'www.example.com\' for base \'example.com\'). Allows filtering by absolute domain level (dot count). NOTE: This differs from relative depth filtering.
     * @summary Find subdomains
     * @param {string} baseDomain Base domain name (e.g., example.com)
     * @param {number} [limit] Maximum number of results
     * @param {FindSubdomainsLevelEnum} [level] Level of subdomains to find relative to the base domain (ALL, IMMEDIATE&#x3D;one level deeper, MAX_DEPTH&#x3D;deepest found relative to base).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainManagementApi
     */
    public findSubdomains(baseDomain: string, limit?: number, level?: FindSubdomainsLevelEnum, options?: RawAxiosRequestConfig) {
        return DomainManagementApiFp(this.configuration).findSubdomains(baseDomain, limit, level, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindSubdomainsLevelEnum = {
    All: 'ALL',
    Immediate: 'IMMEDIATE',
    MaxDepth: 'MAX_DEPTH'
} as const;
export type FindSubdomainsLevelEnum = typeof FindSubdomainsLevelEnum[keyof typeof FindSubdomainsLevelEnum];


/**
 * IntelligenceServicesApi - axios parameter creator
 * @export
 */
export const IntelligenceServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes a domain name and returns comprehensive intelligence data from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-5 seconds - **Streaming Mode**: Server-Sent Events with 200ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - WHOIS registration data with ownership history - Complete DNS record enumeration (A, AAAA, MX, NS, TXT, CNAME, SOA) - Subdomain discovery and enumeration - Link analysis showing connected domains - IP intelligence for all resolved addresses - Trademark and brand protection status - Infrastructure relationships and shared hosting  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/domain/example.com ```  **Streaming Events:** - `whois`: Domain registration info - `dns`: DNS records - `subdomains`: Discovered subdomains - `ip_intelligence`: Intelligence for each resolved IP - `complete`: Final aggregated data  **Input Processing:** - Automatically strips protocols (http://, https://) - Removes www prefix if present - Validates domain format before processing  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
         * @summary Get comprehensive domain intelligence with streaming support
         * @param {string} domain Domain name to analyze. Can be a root domain or subdomain. Protocol and www prefix are automatically removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainIntelligence: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getDomainIntelligence', 'domain', domain)
            const localVarPath = `/intelligence/v1/domain/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyzes an IP address and returns comprehensive intelligence data aggregated from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-3 seconds - **Streaming Mode**: Server-Sent Events with 150ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - Geolocation with city-level precision and confidence scores - Network topology including ASN, BGP prefixes, and routing visibility - ISP and organization identification - DNS relationships showing associated domains - Risk scoring based on threat intelligence feeds - RPKI validation and routing security assessment - Historical routing data and stability metrics  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/ip/8.8.8.8 ```  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
         * @summary Get comprehensive IP address intelligence with streaming support
         * @param {string} address IPv4 or IPv6 address to analyze. Supports standard notation (e.g., 192.168.1.1 or 2001:db8::1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpIntelligence: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getIpIntelligence', 'address', address)
            const localVarPath = `/intelligence/v1/ip/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntelligenceServicesApi - functional programming interface
 * @export
 */
export const IntelligenceServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntelligenceServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Analyzes a domain name and returns comprehensive intelligence data from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-5 seconds - **Streaming Mode**: Server-Sent Events with 200ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - WHOIS registration data with ownership history - Complete DNS record enumeration (A, AAAA, MX, NS, TXT, CNAME, SOA) - Subdomain discovery and enumeration - Link analysis showing connected domains - IP intelligence for all resolved addresses - Trademark and brand protection status - Infrastructure relationships and shared hosting  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/domain/example.com ```  **Streaming Events:** - `whois`: Domain registration info - `dns`: DNS records - `subdomains`: Discovered subdomains - `ip_intelligence`: Intelligence for each resolved IP - `complete`: Final aggregated data  **Input Processing:** - Automatically strips protocols (http://, https://) - Removes www prefix if present - Validates domain format before processing  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
         * @summary Get comprehensive domain intelligence with streaming support
         * @param {string} domain Domain name to analyze. Can be a root domain or subdomain. Protocol and www prefix are automatically removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainIntelligence(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainIntelligenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainIntelligence(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntelligenceServicesApi.getDomainIntelligence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyzes an IP address and returns comprehensive intelligence data aggregated from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-3 seconds - **Streaming Mode**: Server-Sent Events with 150ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - Geolocation with city-level precision and confidence scores - Network topology including ASN, BGP prefixes, and routing visibility - ISP and organization identification - DNS relationships showing associated domains - Risk scoring based on threat intelligence feeds - RPKI validation and routing security assessment - Historical routing data and stability metrics  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/ip/8.8.8.8 ```  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
         * @summary Get comprehensive IP address intelligence with streaming support
         * @param {string} address IPv4 or IPv6 address to analyze. Supports standard notation (e.g., 192.168.1.1 or 2001:db8::1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIpIntelligence(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IpIntelligenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIpIntelligence(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntelligenceServicesApi.getIpIntelligence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntelligenceServicesApi - factory interface
 * @export
 */
export const IntelligenceServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntelligenceServicesApiFp(configuration)
    return {
        /**
         * Analyzes a domain name and returns comprehensive intelligence data from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-5 seconds - **Streaming Mode**: Server-Sent Events with 200ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - WHOIS registration data with ownership history - Complete DNS record enumeration (A, AAAA, MX, NS, TXT, CNAME, SOA) - Subdomain discovery and enumeration - Link analysis showing connected domains - IP intelligence for all resolved addresses - Trademark and brand protection status - Infrastructure relationships and shared hosting  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/domain/example.com ```  **Streaming Events:** - `whois`: Domain registration info - `dns`: DNS records - `subdomains`: Discovered subdomains - `ip_intelligence`: Intelligence for each resolved IP - `complete`: Final aggregated data  **Input Processing:** - Automatically strips protocols (http://, https://) - Removes www prefix if present - Validates domain format before processing  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
         * @summary Get comprehensive domain intelligence with streaming support
         * @param {string} domain Domain name to analyze. Can be a root domain or subdomain. Protocol and www prefix are automatically removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainIntelligence(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainIntelligenceResponse> {
            return localVarFp.getDomainIntelligence(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyzes an IP address and returns comprehensive intelligence data aggregated from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-3 seconds - **Streaming Mode**: Server-Sent Events with 150ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - Geolocation with city-level precision and confidence scores - Network topology including ASN, BGP prefixes, and routing visibility - ISP and organization identification - DNS relationships showing associated domains - Risk scoring based on threat intelligence feeds - RPKI validation and routing security assessment - Historical routing data and stability metrics  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/ip/8.8.8.8 ```  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
         * @summary Get comprehensive IP address intelligence with streaming support
         * @param {string} address IPv4 or IPv6 address to analyze. Supports standard notation (e.g., 192.168.1.1 or 2001:db8::1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpIntelligence(address: string, options?: RawAxiosRequestConfig): AxiosPromise<IpIntelligenceResponse> {
            return localVarFp.getIpIntelligence(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntelligenceServicesApi - object-oriented interface
 * @export
 * @class IntelligenceServicesApi
 * @extends {BaseAPI}
 */
export class IntelligenceServicesApi extends BaseAPI {
    /**
     * Analyzes a domain name and returns comprehensive intelligence data from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-5 seconds - **Streaming Mode**: Server-Sent Events with 200ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - WHOIS registration data with ownership history - Complete DNS record enumeration (A, AAAA, MX, NS, TXT, CNAME, SOA) - Subdomain discovery and enumeration - Link analysis showing connected domains - IP intelligence for all resolved addresses - Trademark and brand protection status - Infrastructure relationships and shared hosting  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/domain/example.com ```  **Streaming Events:** - `whois`: Domain registration info - `dns`: DNS records - `subdomains`: Discovered subdomains - `ip_intelligence`: Intelligence for each resolved IP - `complete`: Final aggregated data  **Input Processing:** - Automatically strips protocols (http://, https://) - Removes www prefix if present - Validates domain format before processing  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
     * @summary Get comprehensive domain intelligence with streaming support
     * @param {string} domain Domain name to analyze. Can be a root domain or subdomain. Protocol and www prefix are automatically removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelligenceServicesApi
     */
    public getDomainIntelligence(domain: string, options?: RawAxiosRequestConfig) {
        return IntelligenceServicesApiFp(this.configuration).getDomainIntelligence(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyzes an IP address and returns comprehensive intelligence data aggregated from multiple sources.  **ðŸš€ Response Modes:** - **Batch Mode** (Default): Complete JSON response in 2-3 seconds - **Streaming Mode**: Server-Sent Events with 150ms time-to-first-byte   - Accept: `application/json` for batch mode   - Accept: `text/event-stream` for streaming mode  **Key Features:** - Geolocation with city-level precision and confidence scores - Network topology including ASN, BGP prefixes, and routing visibility - ISP and organization identification - DNS relationships showing associated domains - Risk scoring based on threat intelligence feeds - RPKI validation and routing security assessment - Historical routing data and stability metrics  **Streaming Example:** ```bash curl -N -H \'Accept: text/event-stream\' \\      -H \'Authorization: Bearer {token}\' \\      https://api.example.com/intelligence/v1/ip/8.8.8.8 ```  **Note:** Swagger UI only displays batch mode. Use curl or EventSource for streaming.
     * @summary Get comprehensive IP address intelligence with streaming support
     * @param {string} address IPv4 or IPv6 address to analyze. Supports standard notation (e.g., 192.168.1.1 or 2001:db8::1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelligenceServicesApi
     */
    public getIpIntelligence(address: string, options?: RawAxiosRequestConfig) {
        return IntelligenceServicesApiFp(this.configuration).getIpIntelligence(address, options).then((request) => request(this.axios, this.basePath));
    }
}



