/* tslint:disable */
/* eslint-disable */
/**
 * Whisper API v1
 * <h2>The Foundational Intelligence Layer for the Internet</h2> <p>The Whisper API provides comprehensive, real-time intelligence on any internet asset. By connecting billions of data points across live internet routing, historical registration records, and deep resolution data, our API moves beyond simple enrichment to deliver predictive, context-rich insights.</p> <p>This document is the single source of truth for our v1 API. It is designed for security experts, developers, and automated systems to understand and leverage the full power of our platform.</p>  <h3>üöÄ Quick Start</h3> <p><b>1. Get your API key:</b> <a href=\"https://dash.whisper.security\">Sign up at dash.whisper.security</a></p> <p><b>2. Make your first request:</b></p> <pre><code>curl -H \"Authorization: Bearer YOUR_API_KEY\" https://api.whisper.security/v1/indicators/ip/8.8.8.8</code></pre> <p><b>3. Explore the API:</b> Use the \"Try it out\" button in each endpoint below to test interactively.</p>  <h3>üéØ Key Features</h3> <ul>     <li><b>Unified & Simple:</b> Small set of powerful, resource-oriented endpoints</li>     <li><b>Performant by Design:</b> Asynchronous-first with strategic caching (&lt;500ms typical response)</li>     <li><b>Workflow-Oriented:</b> Built for real-world security operations, not just data dumps</li>     <li><b>Comprehensive:</b> IP, Domain, DNS, WHOIS, Routing, Geolocation, Screenshots, Monitoring</li> </ul>  <h3>‚ö° Performance Targets</h3> <table>     <tr><th>Endpoint Type</th><th>Response Time</th><th>Use Case</th></tr>     <tr><td>Geolocation</td><td>&lt;150ms</td><td>Real-time fraud detection</td></tr>     <tr><td>Single Indicator</td><td>&lt;500ms</td><td>Incident response enrichment</td></tr>     <tr><td>With Routing Data</td><td>&lt;2s (cached: 200ms)</td><td>Deep network analysis</td></tr>     <tr><td>Bulk Operations</td><td>5-30s</td><td>Batch log enrichment</td></tr>     <tr><td>Search/Discovery</td><td>10-60s</td><td>Threat hunting</td></tr> </table>  <h3>üîê Authentication</h3> <p>All endpoints require Bearer token authentication. Click the <b>\"Authorize\"</b> button above and enter your API key.</p> <pre><code>Authorization: Bearer wsk_live_1234567890abcdef</code></pre>  <h3>üìä Rate Limits</h3> <table>     <tr><th>Category</th><th>Limit</th></tr>     <tr><td>Standard Enrichment</td><td>100 req/min</td></tr>     <tr><td>Bulk Operations</td><td>10 req/min</td></tr>     <tr><td>Search/Discovery</td><td>5 req/min</td></tr>     <tr><td>Screenshots</td><td>10 req/min</td></tr> </table> <p><i>Rate limits return HTTP 429. Retry after the time specified in the <code>Retry-After</code> header.</i></p>  <h3>üìö Resources</h3> <ul>     <li><a href=\"https://docs.whisper.security\">Full Documentation</a></li>     <li><a href=\"https://docs.whisper.security/quickstart\">Quick Start Guide</a></li>     <li><a href=\"https://docs.whisper.security/examples\">Code Examples</a></li>     <li><a href=\"https://whisper.security/support\">API Support</a></li> </ul> 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@whisper.security
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Configuration for bitsquatting (bit-flip) variations
 */
export interface BitsquattingConfig {
    /**
     * Maximum bit flips per character
     */
    'max_bit_flips'?: number;
}
/**
 * Blacklist scores at different network levels
 */
export interface BlacklistScores {
    /**
     * IP-level blacklist score
     */
    'ip_score'?: number;
    /**
     * Network prefix blacklist score
     */
    'prefix_score'?: number;
    /**
     * ASN-level blacklist score
     */
    'asn_score'?: number;
}
/**
 * Advanced configuration options for bulk processing behavior
 */
export interface BulkOptions {
    /**
     * Enable parallel processing of indicators for faster results
     */
    'parallel_processing'?: boolean;
    /**
     * Number of indicators to process in each batch. Smaller batches = more frequent progress updates
     */
    'batch_size'?: number;
    /**
     * Maximum time in milliseconds to wait for each indicator before timing out
     */
    'timeout_per_indicator'?: number;
    /**
     * Continue processing remaining indicators if one fails. Recommended for large batches.
     */
    'continue_on_error'?: boolean;
    /**
     * Include failed indicators in the response with error details
     */
    'include_failed'?: boolean;
}
/**
 * Request payload for bulk enrichment of multiple IP addresses and domains
 */
export interface BulkRequest {
    /**
     * List of indicators (IP addresses or domains) to enrich. Mix of IPs and domains is supported.
     */
    'indicators': Array<string>;
    /**
     * Additional data modules to include for each indicator. Same options as single indicator endpoint.
     */
    'include'?: Set<BulkRequestIncludeEnum>;
    'options'?: BulkOptions;
}

export const BulkRequestIncludeEnum = {
    Routing: 'routing',
    Rpki: 'rpki',
    Whois: 'whois',
    DnsDetails: 'dns_details',
    IpIntelligence: 'ip_intelligence'
} as const;

export type BulkRequestIncludeEnum = typeof BulkRequestIncludeEnum[keyof typeof BulkRequestIncludeEnum];

/**
 * Configuration for DNS enumeration and subdomain discovery
 */
export interface DnsEnumConfig {
    /**
     * Enable subdomain enumeration
     */
    'subdomain_enum'?: boolean;
    /**
     * Enable DNS zone transfer attempts
     */
    'zone_transfer'?: boolean;
    /**
     * Enable reverse DNS lookups
     */
    'reverse_dns'?: boolean;
    /**
     * Wordlist size for subdomain brute-forcing
     */
    'wordlist_size'?: DnsEnumConfigWordlistSizeEnum;
}

export const DnsEnumConfigWordlistSizeEnum = {
    Small: 'small',
    Medium: 'medium',
    Large: 'large'
} as const;

export type DnsEnumConfigWordlistSizeEnum = typeof DnsEnumConfigWordlistSizeEnum[keyof typeof DnsEnumConfigWordlistSizeEnum];

/**
 * DNS records and resolution data for the domain
 */
export interface DnsInfo {
    'arecords'?: Array<string>;
    /**
     * A records (IPv4 addresses)
     */
    'a_records'?: Array<string>;
    /**
     * AAAA records (IPv6 addresses)
     */
    'aaaa_records'?: Array<string>;
    /**
     * MX records (mail servers) with priority and hostname
     */
    'mx_records'?: Array<object>;
    /**
     * NS records (name servers)
     */
    'ns_records'?: Array<string>;
    /**
     * TXT records (text records for SPF, DKIM, etc.)
     */
    'txt_records'?: Array<string>;
    /**
     * CNAME records (canonical name aliases)
     */
    'cname_records'?: Array<string>;
}
/**
 * Detailed infrastructure and individual IP scores
 */
export interface DomainReputationDetails {
    /**
     * Domain\'s A record IP addresses
     */
    'domain_ips'?: Array<string>;
    /**
     * Individual scores for each domain IP
     */
    'domain_ip_scores'?: { [key: string]: number; };
    /**
     * Nameserver domain names
     */
    'nameserver_domains'?: Array<string>;
    /**
     * IP addresses of nameservers
     */
    'nameserver_ips'?: Array<string>;
    /**
     * Individual scores for each nameserver IP
     */
    'nameserver_ip_scores'?: { [key: string]: number; };
    /**
     * Mail server domain names
     */
    'mailserver_domains'?: Array<string>;
    /**
     * IP addresses of mail servers
     */
    'mailserver_ips'?: Array<string>;
    /**
     * Individual scores for each mail server IP
     */
    'mailserver_ip_scores'?: { [key: string]: number; };
}
/**
 * Domain reputation calculated from infrastructure IP scores
 */
export interface DomainReputationScores {
    /**
     * Overall reputation score (0-100, higher = more suspicious)
     */
    'overall_score'?: number;
    /**
     * Risk classification based on overall score
     */
    'risk_level'?: DomainReputationScoresRiskLevelEnum;
    /**
     * Average IP reputation score for domain\'s A records
     */
    'domain_ip_score'?: number;
    /**
     * Average IP reputation score for nameserver IPs
     */
    'nameserver_ip_score'?: number;
    /**
     * Average IP reputation score for mail server IPs
     */
    'mailserver_ip_score'?: number;
    'details'?: DomainReputationDetails;
    /**
     * Scoring methodology used
     */
    'scoring_method'?: string;
    /**
     * Weighting strategy applied to infrastructure components
     */
    'weights'?: { [key: string]: number; };
}

export const DomainReputationScoresRiskLevelEnum = {
    Clean: 'clean',
    LowRisk: 'low_risk',
    MediumRisk: 'medium_risk',
    HighRisk: 'high_risk',
    Malicious: 'malicious'
} as const;

export type DomainReputationScoresRiskLevelEnum = typeof DomainReputationScoresRiskLevelEnum[keyof typeof DomainReputationScoresRiskLevelEnum];

/**
 * Standard error response returned when an API request fails
 */
export interface ErrorResponse {
    /**
     * The HTTP status code of the error
     */
    'status': number;
    /**
     * A short, machine-readable error code
     */
    'error': string;
    /**
     * A human-readable error message providing more detail
     */
    'message': string;
    /**
     * Additional details about the error, including field-specific validation errors
     */
    'details'?: object;
    /**
     * The timestamp when the error occurred
     */
    'timestamp': string;
    /**
     * A unique trace ID for this request, useful for debugging
     */
    'trace_id'?: string;
    /**
     * The API path that generated this error
     */
    'path'?: string;
}
export interface HistoryData {
    'records'?: Array<object>;
    'total_records'?: number;
    'oldest_date'?: string;
    'newest_date'?: string;
    'message'?: string;
}
export interface HistoryResponse {
    'query'?: QueryInfo;
    'history'?: HistoryData;
}
/**
 * Configuration for homoglyph (look-alike character) variations
 */
export interface HomoglyphConfig {
    /**
     * Include Cyrillic character substitutions
     */
    'cyrillic'?: boolean;
    /**
     * Include Greek character substitutions
     */
    'greek'?: boolean;
    /**
     * Include Latin character substitutions
     */
    'latin'?: boolean;
    /**
     * Maximum number of character substitutions per domain
     */
    'max_substitutions'?: number;
}
/**
 * Comprehensive intelligence response for an IP address or domain indicator
 */
export interface IndicatorResponse {
    'query'?: QueryInfo;
    'summary'?: SummaryInfo;
    'geolocation'?: object;
    'network'?: object;
    'isp'?: object;
    'registration'?: object;
    'dns'?: DnsInfo;
    'relationships'?: RelationshipInfo;
    'reputation'?: ReputationInfo;
    'security'?: object;
    /**
     * When domain is queried with include=ip_intelligence, contains full intelligence for each resolved IP
     */
    'ip_intelligence'?: { [key: string]: object; };
    'metadata'?: MetadataInfo;
}
/**
 * Configuration for performing infrastructure discovery and security scanning
 */
export interface InfraScanRequest {
    /**
     * The target to scan (IP, CIDR, domain, or ASN)
     */
    'target': string;
    /**
     * Type of target being scanned
     */
    'target_type': InfraScanRequestTargetTypeEnum;
    /**
     * Types of scans to perform
     */
    'scan_types'?: Set<string>;
    /**
     * Scan depth level
     */
    'scan_depth'?: InfraScanRequestScanDepthEnum;
    /**
     * Maximum scan duration in seconds
     */
    'timeout'?: number;
    'options'?: ScanOptions;
}

export const InfraScanRequestTargetTypeEnum = {
    Ip: 'ip',
    Cidr: 'cidr',
    Domain: 'domain',
    Asn: 'asn'
} as const;

export type InfraScanRequestTargetTypeEnum = typeof InfraScanRequestTargetTypeEnum[keyof typeof InfraScanRequestTargetTypeEnum];
export const InfraScanRequestScanDepthEnum = {
    Light: 'light',
    Medium: 'medium',
    Deep: 'deep'
} as const;

export type InfraScanRequestScanDepthEnum = typeof InfraScanRequestScanDepthEnum[keyof typeof InfraScanRequestScanDepthEnum];

export interface Job {
    'id'?: string;
    'status'?: JobStatusEnum;
    'type'?: string;
    'params'?: object;
    'result'?: object;
    'error'?: JobError;
    'progress'?: JobProgress;
    'createdAt'?: string;
    'updatedAt'?: string;
    'completedAt'?: string;
    'metadata'?: { [key: string]: string; };
    'username'?: string;
}

export const JobStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type JobStatusEnum = typeof JobStatusEnum[keyof typeof JobStatusEnum];

export interface JobError {
    'code'?: string;
    'message'?: string;
    'details'?: string;
    'timestamp'?: string;
}
export interface JobProgress {
    'current'?: number;
    'total'?: number;
    'message'?: string;
    'percentage'?: number;
}
export interface JobResponse {
    'job_id'?: string;
    'status'?: string;
    'status_url'?: string;
    'message'?: string;
}
/**
 * Link statistics and top sources
 */
export interface LinksInfo {
    /**
     * Total number of links
     */
    'total'?: number;
    /**
     * Top linking sources
     */
    'top_sources'?: Array<string>;
}
/**
 * Response metadata including data sources and any errors encountered
 */
export interface MetadataInfo {
    /**
     * List of data sources used to build this response
     */
    'data_sources'?: Array<string>;
    /**
     * Any non-fatal errors encountered during data collection. Empty if all sources succeeded.
     */
    'errors'?: Array<string>;
}
/**
 * Configuration for port scanning
 */
export interface PortScanConfig {
    /**
     * Ports to scan (comma-separated or range)
     */
    'ports'?: string;
    /**
     * Scan technique
     */
    'technique'?: PortScanConfigTechniqueEnum;
    /**
     * Number of parallel threads
     */
    'threads'?: number;
    /**
     * Timeout per port in milliseconds
     */
    'port_timeout'?: number;
}

export const PortScanConfigTechniqueEnum = {
    Syn: 'syn',
    Connect: 'connect',
    Udp: 'udp',
    Comprehensive: 'comprehensive'
} as const;

export type PortScanConfigTechniqueEnum = typeof PortScanConfigTechniqueEnum[keyof typeof PortScanConfigTechniqueEnum];

export interface QueryInfo {
    'indicator'?: string;
    'indicator_type'?: string;
    'history_type'?: string;
    'timestamp'?: string;
    'response_time_ms'?: number;
}
/**
 * Connections and relationships to other infrastructure and domains
 */
export interface RelationshipInfo {
    'incoming_links'?: LinksInfo;
    'outgoing_links'?: LinksInfo;
    /**
     * Related domains (same owner, same network, similar content)
     */
    'related_domains'?: Array<string>;
    /**
     * Other assets sharing the same infrastructure (IP, ASN, nameservers)
     */
    'shared_infrastructure'?: Array<string>;
}
/**
 * Reputation scoring and blacklist information for threat assessment
 */
export interface ReputationInfo {
    /**
     * Composite risk score (0-10, higher = riskier)
     */
    'risk_score'?: number;
    'blacklists'?: BlacklistScores;
    'domain_reputation'?: DomainReputationScores;
}
/**
 * Advanced configuration options for infrastructure scanning
 */
export interface ScanOptions {
    'port_scan'?: PortScanConfig;
    'service_discovery'?: ServiceDiscoveryConfig;
    'vulnerability'?: VulnerabilityConfig;
    'dns_enum'?: DnsEnumConfig;
}
/**
 * Configuration for scheduling recurring screenshot captures
 */
export interface ScheduleConfig {
    /**
     * Cron expression for scheduling
     */
    'cron'?: string;
    /**
     * Frequency of captures
     */
    'frequency'?: ScheduleConfigFrequencyEnum;
    /**
     * Timezone for scheduled captures
     */
    'timezone'?: string;
    /**
     * Maximum number of captures to retain
     */
    'retention_count'?: number;
    /**
     * Enable/disable the schedule
     */
    'enabled'?: boolean;
}

export const ScheduleConfigFrequencyEnum = {
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type ScheduleConfigFrequencyEnum = typeof ScheduleConfigFrequencyEnum[keyof typeof ScheduleConfigFrequencyEnum];

/**
 * Configuration options for screenshot capture
 */
export interface ScreenshotOptions {
    /**
     * Viewport width in pixels
     */
    'width'?: number;
    /**
     * Viewport height in pixels
     */
    'height'?: number;
    /**
     * Capture the full page height (scrolling screenshot)
     */
    'full_page'?: boolean;
    /**
     * Wait time in milliseconds before taking screenshot
     */
    'wait_time'?: number;
    /**
     * Image format for the screenshot
     */
    'format'?: ScreenshotOptionsFormatEnum;
    /**
     * Image quality (1-100, only for jpeg/webp)
     */
    'quality'?: number;
    /**
     * User agent string to use for the request
     */
    'user_agent'?: string;
    /**
     * Enable JavaScript execution
     */
    'javascript'?: boolean;
    /**
     * Block ads and trackers
     */
    'block_ads'?: boolean;
    /**
     * Accept cookies consent if prompted
     */
    'accept_cookies'?: boolean;
}

export const ScreenshotOptionsFormatEnum = {
    Png: 'png',
    Jpeg: 'jpeg',
    Webp: 'webp'
} as const;

export type ScreenshotOptionsFormatEnum = typeof ScreenshotOptionsFormatEnum[keyof typeof ScreenshotOptionsFormatEnum];

/**
 * Request parameters for capturing a website screenshot
 */
export interface ScreenshotRequest {
    /**
     * The URL of the website to capture
     */
    'url': string;
    'options'?: ScreenshotOptions;
    'schedule'?: ScheduleConfig;
}
/**
 * Search query for finding indicators matching specific criteria. Powerful for threat hunting and infrastructure discovery.
 */
export interface SearchRequest {
    /**
     * Search query using field:value syntax. Supports multiple fields combined with logical operators.  **Supported Fields:** - WHOIS: `registrantCompany`, `registrantName`, `registrantEmail`, `registrar` - Network: `asn`, `network`, `country_code`, `city` - Domain: `tld`, `domain_length`, `creation_date`  **Examples:** - `registrantCompany:EvilCorp` - Find domains by registrant - `asn:15169 AND country_code:US` - Complex query with AND - `registrantEmail:admin@example.com` - Find domains by email 
     */
    'query': string;
    /**
     * Additional filters to narrow down search results. Applied after query matching.
     */
    'filters'?: { [key: string]: string; };
    /**
     * Maximum number of results to return per page
     */
    'limit'?: number;
    /**
     * Number of results to skip for pagination. Use with limit for paginated results.
     */
    'offset'?: number;
    /**
     * Field to sort results by
     */
    'sort_by'?: SearchRequestSortByEnum;
    /**
     * Sort order
     */
    'sort_order'?: SearchRequestSortOrderEnum;
}

export const SearchRequestSortByEnum = {
    RegistrationDate: 'registration_date',
    ExpirationDate: 'expiration_date',
    RiskScore: 'risk_score',
    DomainName: 'domain_name',
    Asn: 'asn'
} as const;

export type SearchRequestSortByEnum = typeof SearchRequestSortByEnum[keyof typeof SearchRequestSortByEnum];
export const SearchRequestSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SearchRequestSortOrderEnum = typeof SearchRequestSortOrderEnum[keyof typeof SearchRequestSortOrderEnum];

/**
 * Configuration for service and version detection
 */
export interface ServiceDiscoveryConfig {
    /**
     * Enable service version detection
     */
    'version_detection'?: boolean;
    /**
     * Enable OS fingerprinting
     */
    'os_detection'?: boolean;
    /**
     * Aggressiveness of service detection (1-9)
     */
    'intensity'?: number;
    /**
     * Enable script scanning
     */
    'script_scan'?: boolean;
}
/**
 * Configuration for generating similar domain variations for brand protection and threat hunting
 */
export interface SimilarDomainRequest {
    /**
     * Types of domain variations to generate
     */
    'techniques'?: Set<string>;
    /**
     * Maximum number of similar domains to generate
     */
    'limit'?: number;
    /**
     * Check if generated domains are registered
     */
    'check_registration'?: boolean;
    /**
     * Include DNS resolution data for registered domains
     */
    'include_dns'?: boolean;
    /**
     * Calculate risk scores for each variation
     */
    'include_risk_score'?: boolean;
    'technique_config'?: TechniqueConfig;
}
/**
 * Detailed information about a discovered subdomain
 */
export interface SubdomainInfo {
    /**
     * The full subdomain name
     */
    'subdomain': string;
    /**
     * IP addresses associated with the subdomain
     */
    'ip_addresses'?: Array<string>;
    /**
     * First time this subdomain was observed
     */
    'first_seen'?: string;
    /**
     * Last time this subdomain was observed
     */
    'last_seen'?: string;
    /**
     * Type of subdomain record
     */
    'record_type'?: SubdomainInfoRecordTypeEnum;
    /**
     * Current status of the subdomain
     */
    'status'?: SubdomainInfoStatusEnum;
    /**
     * Technology stack detected on this subdomain
     */
    'technologies'?: Array<string>;
    /**
     * Risk score for this subdomain (0-100)
     */
    'risk_score'?: number;
}

export const SubdomainInfoRecordTypeEnum = {
    A: 'A',
    Aaaa: 'AAAA',
    Cname: 'CNAME',
    Mx: 'MX',
    Txt: 'TXT',
    Ns: 'NS'
} as const;

export type SubdomainInfoRecordTypeEnum = typeof SubdomainInfoRecordTypeEnum[keyof typeof SubdomainInfoRecordTypeEnum];
export const SubdomainInfoStatusEnum = {
    Active: 'active',
    Inactive: 'inactive',
    Parked: 'parked'
} as const;

export type SubdomainInfoStatusEnum = typeof SubdomainInfoStatusEnum[keyof typeof SubdomainInfoStatusEnum];

/**
 * Response containing discovered subdomains and related metadata
 */
export interface SubdomainResponse {
    /**
     * The root domain that was queried
     */
    'domain': string;
    /**
     * Total number of subdomains discovered
     */
    'total_count': number;
    /**
     * List of discovered subdomains
     */
    'subdomains': Array<SubdomainInfo>;
    /**
     * Timestamp of when the data was retrieved
     */
    'timestamp': string;
    /**
     * Data sources used for subdomain discovery
     */
    'sources'?: Array<string>;
}
/**
 * Executive summary with the most important facts for quick decision-making
 */
export interface SummaryInfo {
    /**
     * Primary organization name
     */
    'organization'?: string;
    /**
     * Primary location
     */
    'location'?: string;
    /**
     * Network range or CIDR
     */
    'network'?: string;
    /**
     * Domain registrar
     */
    'registrar'?: string;
    /**
     * Domain status
     */
    'status'?: SummaryInfoStatusEnum;
    /**
     * Primary ASN
     */
    'asn_primary'?: string;
    /**
     * Composite risk score (0-10, higher is riskier)
     */
    'risk_score'?: number;
    /**
     * IP classification
     */
    'ip_type'?: SummaryInfoIpTypeEnum;
    /**
     * Total number of domains resolving to this IP
     */
    'total_domains'?: number;
    /**
     * The domain name
     */
    'domain_name'?: string;
    /**
     * Domain registration date
     */
    'registration_date'?: string;
    /**
     * Domain expiration date
     */
    'expiration_date'?: string;
    /**
     * Primary DNS provider
     */
    'dns_provider'?: string;
    /**
     * Number of incoming links/backlinks
     */
    'total_links_in'?: number;
    /**
     * Number of outgoing links
     */
    'total_links_out'?: number;
}

export const SummaryInfoStatusEnum = {
    Active: 'active',
    Expired: 'expired',
    Pending: 'pending',
    Suspended: 'suspended',
    Deleted: 'deleted'
} as const;

export type SummaryInfoStatusEnum = typeof SummaryInfoStatusEnum[keyof typeof SummaryInfoStatusEnum];
export const SummaryInfoIpTypeEnum = {
    Residential: 'residential',
    Business: 'business',
    Datacenter: 'datacenter',
    Hosting: 'hosting',
    Vpn: 'vpn',
    Proxy: 'proxy',
    Tor: 'tor',
    Mobile: 'mobile'
} as const;

export type SummaryInfoIpTypeEnum = typeof SummaryInfoIpTypeEnum[keyof typeof SummaryInfoIpTypeEnum];

/**
 * Detailed configuration for each domain variation technique
 */
export interface TechniqueConfig {
    'typosquatting'?: TyposquattingConfig;
    'homoglyph'?: HomoglyphConfig;
    'bitsquatting'?: BitsquattingConfig;
    'tld_variation'?: TldVariationConfig;
}
/**
 * Configuration for top-level domain variations
 */
export interface TldVariationConfig {
    /**
     * Include common TLD variations (.com, .net, .org, etc.)
     */
    'common_tlds'?: boolean;
    /**
     * Include country-code TLDs
     */
    'country_tlds'?: boolean;
    /**
     * Include new generic TLDs (.app, .dev, .cloud, etc.)
     */
    'new_gtlds'?: boolean;
    /**
     * Custom TLDs to check
     */
    'custom_tlds'?: Set<string>;
}
/**
 * Configuration for typosquatting variations
 */
export interface TyposquattingConfig {
    /**
     * Include character omission variations
     */
    'character_omission'?: boolean;
    /**
     * Include character swap variations
     */
    'character_swap'?: boolean;
    /**
     * Include double character variations
     */
    'double_character'?: boolean;
    /**
     * Include keyboard proximity variations
     */
    'keyboard_proximity'?: boolean;
}
/**
 * Configuration for vulnerability scanning
 */
export interface VulnerabilityConfig {
    /**
     * Check for CVEs
     */
    'check_cves'?: boolean;
    /**
     * Minimum CVSS score to report
     */
    'min_cvss_score'?: number;
    /**
     * Check for default credentials
     */
    'default_credentials'?: boolean;
    /**
     * Check for misconfigurations
     */
    'misconfigurations'?: boolean;
    /**
     * Include proof-of-concept exploits
     */
    'include_poc'?: boolean;
}

/**
 * IndicatorsApi - axios parameter creator
 */
export const IndicatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p> <p><b>Performance:</b> Processing time depends on batch size and requested data modules. Expect 5-30 seconds for typical batches.</p> <p><b>Rate Limits:</b> Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p> 
         * @summary Bulk Indicator Enrichment (Asynchronous)
         * @param {BulkRequest} bulkRequest List of indicators and processing options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkEnrichment: async (bulkRequest: BulkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkRequest' is not null or undefined
            assertParamExists('bulkEnrichment', 'bulkRequest', bulkRequest)
            const localVarPath = `/v1/indicators/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Initiates an asynchronous job to generate potential lookalike domains using default options. This GET variant is provided for convenience.</p> <p>For custom options (algorithms, limits, etc.), use the POST version of this endpoint.</p> <p>The API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when complete.</p> 
         * @summary Generate Similar Domains - GET (Asynchronous)
         * @param {string} domain The domain to generate variations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSimilarDomainsGet: async (domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('generateSimilarDomainsGet', 'domain', domain)
            const localVarPath = `/v1/indicators/domain/{domain}/similar`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Initiates an asynchronous job to generate potential lookalike domains for typosquatting, homoglyph, and brand protection analysis. This is a powerful tool for proactive threat hunting.</p> <p>Because this can be a long-running process, the API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when the job is complete.</p> <p>Use this POST version to specify custom options like algorithms, limits, or filters.</p> 
         * @summary Generate Similar Domains - POST (Asynchronous)
         * @param {string} domain The domain to generate variations for.
         * @param {SimilarDomainRequest} [similarDomainRequest] Configuration for the similarity generation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSimilarDomainsPost: async (domain: string, similarDomainRequest?: SimilarDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('generateSimilarDomainsPost', 'domain', domain)
            const localVarPath = `/v1/indicators/domain/{domain}/similar`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(similarDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 
         * @summary Enrich a Single Indicator (IP or Domain)
         * @param {GetIndicatorTypeEnum} type The type of indicator to enrich.
         * @param {string} value The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).
         * @param {GetIndicatorIncludeEnum} [include] A comma-separated list of additional data modules to include in the response. Requesting more modules may increase latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicator: async (type: GetIndicatorTypeEnum, value: string, include?: GetIndicatorIncludeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIndicator', 'type', type)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('getIndicator', 'value', value)
            const localVarPath = `/v1/indicators/{type}/{value}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 
         * @summary Get Infrastructure Relationship Graph
         * @param {GetIndicatorGraphTypeEnum} type Type of indicator
         * @param {string} value The indicator value (IP address or domain)
         * @param {number} [limit] Maximum number of nodes to return in the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicatorGraph: async (type: GetIndicatorGraphTypeEnum, value: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIndicatorGraph', 'type', type)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('getIndicatorGraph', 'value', value)
            const localVarPath = `/v1/indicators/{type}/{value}/graph`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 
         * @summary Get Historical Data for Indicator
         * @param {GetIndicatorHistoryTypeEnum} type Type of indicator
         * @param {string} value The indicator value (IP address or domain)
         * @param {GetIndicatorHistoryHistoryTypeEnum} [historyType] Type of historical data to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicatorHistory: async (type: GetIndicatorHistoryTypeEnum, value: string, historyType?: GetIndicatorHistoryHistoryTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIndicatorHistory', 'type', type)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('getIndicatorHistory', 'value', value)
            const localVarPath = `/v1/indicators/{type}/{value}/history`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (historyType !== undefined) {
                localVarQueryParameter['historyType'] = historyType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.
         * @summary Get Domain Subdomains
         * @param {string} domain The root domain to query for subdomains.
         * @param {number} [limit] The maximum number of subdomains to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubdomains: async (domain: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getSubdomains', 'domain', domain)
            const localVarPath = `/v1/indicators/domain/{domain}/subdomains`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Initiates an asynchronous job to search for indicators matching specific criteria. This endpoint is extremely powerful for infrastructure discovery and threat hunting.</p> <p><b>Performance Note:</b> Searches on WHOIS fields (like `registrantCompany`) are data-intensive and can take over 50 seconds to complete. This endpoint is therefore asynchronous by design. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve results.</p> <h4>Example Search Queries:</h4> <ul>     <li>`registrantCompany:EvilCorp` - Find all domains registered by EvilCorp</li>     <li>`asn:15169` - Find all IPs in Google\'s ASN</li>     <li>`city:\"San Francisco\"` - Find all IPs geolocated to San Francisco</li> </ul> 
         * @summary Search Indicators (Asynchronous)
         * @param {SearchRequest} searchRequest The search query and configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIndicators: async (searchRequest: SearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists('searchIndicators', 'searchRequest', searchRequest)
            const localVarPath = `/v1/indicators/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndicatorsApi - functional programming interface
 */
export const IndicatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IndicatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p> <p><b>Performance:</b> Processing time depends on batch size and requested data modules. Expect 5-30 seconds for typical batches.</p> <p><b>Rate Limits:</b> Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p> 
         * @summary Bulk Indicator Enrichment (Asynchronous)
         * @param {BulkRequest} bulkRequest List of indicators and processing options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkEnrichment(bulkRequest: BulkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkEnrichment(bulkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.bulkEnrichment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Initiates an asynchronous job to generate potential lookalike domains using default options. This GET variant is provided for convenience.</p> <p>For custom options (algorithms, limits, etc.), use the POST version of this endpoint.</p> <p>The API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when complete.</p> 
         * @summary Generate Similar Domains - GET (Asynchronous)
         * @param {string} domain The domain to generate variations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSimilarDomainsGet(domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSimilarDomainsGet(domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.generateSimilarDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Initiates an asynchronous job to generate potential lookalike domains for typosquatting, homoglyph, and brand protection analysis. This is a powerful tool for proactive threat hunting.</p> <p>Because this can be a long-running process, the API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when the job is complete.</p> <p>Use this POST version to specify custom options like algorithms, limits, or filters.</p> 
         * @summary Generate Similar Domains - POST (Asynchronous)
         * @param {string} domain The domain to generate variations for.
         * @param {SimilarDomainRequest} [similarDomainRequest] Configuration for the similarity generation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSimilarDomainsPost(domain: string, similarDomainRequest?: SimilarDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSimilarDomainsPost(domain, similarDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.generateSimilarDomainsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 
         * @summary Enrich a Single Indicator (IP or Domain)
         * @param {GetIndicatorTypeEnum} type The type of indicator to enrich.
         * @param {string} value The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).
         * @param {GetIndicatorIncludeEnum} [include] A comma-separated list of additional data modules to include in the response. Requesting more modules may increase latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicator(type: GetIndicatorTypeEnum, value: string, include?: GetIndicatorIncludeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndicatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicator(type, value, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.getIndicator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 
         * @summary Get Infrastructure Relationship Graph
         * @param {GetIndicatorGraphTypeEnum} type Type of indicator
         * @param {string} value The indicator value (IP address or domain)
         * @param {number} [limit] Maximum number of nodes to return in the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicatorGraph(type: GetIndicatorGraphTypeEnum, value: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicatorGraph(type, value, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.getIndicatorGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 
         * @summary Get Historical Data for Indicator
         * @param {GetIndicatorHistoryTypeEnum} type Type of indicator
         * @param {string} value The indicator value (IP address or domain)
         * @param {GetIndicatorHistoryHistoryTypeEnum} [historyType] Type of historical data to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndicatorHistory(type: GetIndicatorHistoryTypeEnum, value: string, historyType?: GetIndicatorHistoryHistoryTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndicatorHistory(type, value, historyType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.getIndicatorHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.
         * @summary Get Domain Subdomains
         * @param {string} domain The root domain to query for subdomains.
         * @param {number} [limit] The maximum number of subdomains to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubdomains(domain: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubdomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubdomains(domain, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.getSubdomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Initiates an asynchronous job to search for indicators matching specific criteria. This endpoint is extremely powerful for infrastructure discovery and threat hunting.</p> <p><b>Performance Note:</b> Searches on WHOIS fields (like `registrantCompany`) are data-intensive and can take over 50 seconds to complete. This endpoint is therefore asynchronous by design. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve results.</p> <h4>Example Search Queries:</h4> <ul>     <li>`registrantCompany:EvilCorp` - Find all domains registered by EvilCorp</li>     <li>`asn:15169` - Find all IPs in Google\'s ASN</li>     <li>`city:\"San Francisco\"` - Find all IPs geolocated to San Francisco</li> </ul> 
         * @summary Search Indicators (Asynchronous)
         * @param {SearchRequest} searchRequest The search query and configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchIndicators(searchRequest: SearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchIndicators(searchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IndicatorsApi.searchIndicators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IndicatorsApi - factory interface
 */
export const IndicatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IndicatorsApiFp(configuration)
    return {
        /**
         * <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p> <p><b>Performance:</b> Processing time depends on batch size and requested data modules. Expect 5-30 seconds for typical batches.</p> <p><b>Rate Limits:</b> Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p> 
         * @summary Bulk Indicator Enrichment (Asynchronous)
         * @param {BulkRequest} bulkRequest List of indicators and processing options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkEnrichment(bulkRequest: BulkRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.bulkEnrichment(bulkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Initiates an asynchronous job to generate potential lookalike domains using default options. This GET variant is provided for convenience.</p> <p>For custom options (algorithms, limits, etc.), use the POST version of this endpoint.</p> <p>The API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when complete.</p> 
         * @summary Generate Similar Domains - GET (Asynchronous)
         * @param {string} domain The domain to generate variations for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSimilarDomainsGet(domain: string, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.generateSimilarDomainsGet(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Initiates an asynchronous job to generate potential lookalike domains for typosquatting, homoglyph, and brand protection analysis. This is a powerful tool for proactive threat hunting.</p> <p>Because this can be a long-running process, the API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when the job is complete.</p> <p>Use this POST version to specify custom options like algorithms, limits, or filters.</p> 
         * @summary Generate Similar Domains - POST (Asynchronous)
         * @param {string} domain The domain to generate variations for.
         * @param {SimilarDomainRequest} [similarDomainRequest] Configuration for the similarity generation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSimilarDomainsPost(domain: string, similarDomainRequest?: SimilarDomainRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.generateSimilarDomainsPost(domain, similarDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 
         * @summary Enrich a Single Indicator (IP or Domain)
         * @param {GetIndicatorTypeEnum} type The type of indicator to enrich.
         * @param {string} value The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).
         * @param {GetIndicatorIncludeEnum} [include] A comma-separated list of additional data modules to include in the response. Requesting more modules may increase latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicator(type: GetIndicatorTypeEnum, value: string, include?: GetIndicatorIncludeEnum, options?: RawAxiosRequestConfig): AxiosPromise<IndicatorResponse> {
            return localVarFp.getIndicator(type, value, include, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 
         * @summary Get Infrastructure Relationship Graph
         * @param {GetIndicatorGraphTypeEnum} type Type of indicator
         * @param {string} value The indicator value (IP address or domain)
         * @param {number} [limit] Maximum number of nodes to return in the graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicatorGraph(type: GetIndicatorGraphTypeEnum, value: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getIndicatorGraph(type, value, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 
         * @summary Get Historical Data for Indicator
         * @param {GetIndicatorHistoryTypeEnum} type Type of indicator
         * @param {string} value The indicator value (IP address or domain)
         * @param {GetIndicatorHistoryHistoryTypeEnum} [historyType] Type of historical data to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndicatorHistory(type: GetIndicatorHistoryTypeEnum, value: string, historyType?: GetIndicatorHistoryHistoryTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<HistoryResponse> {
            return localVarFp.getIndicatorHistory(type, value, historyType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.
         * @summary Get Domain Subdomains
         * @param {string} domain The root domain to query for subdomains.
         * @param {number} [limit] The maximum number of subdomains to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubdomains(domain: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SubdomainResponse> {
            return localVarFp.getSubdomains(domain, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Initiates an asynchronous job to search for indicators matching specific criteria. This endpoint is extremely powerful for infrastructure discovery and threat hunting.</p> <p><b>Performance Note:</b> Searches on WHOIS fields (like `registrantCompany`) are data-intensive and can take over 50 seconds to complete. This endpoint is therefore asynchronous by design. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve results.</p> <h4>Example Search Queries:</h4> <ul>     <li>`registrantCompany:EvilCorp` - Find all domains registered by EvilCorp</li>     <li>`asn:15169` - Find all IPs in Google\'s ASN</li>     <li>`city:\"San Francisco\"` - Find all IPs geolocated to San Francisco</li> </ul> 
         * @summary Search Indicators (Asynchronous)
         * @param {SearchRequest} searchRequest The search query and configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchIndicators(searchRequest: SearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.searchIndicators(searchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IndicatorsApi - object-oriented interface
 */
export class IndicatorsApi extends BaseAPI {
    /**
     * <p>Process multiple indicators (IPs and/or domains) in a single request. This endpoint is optimized for batch processing and can handle up to 100 indicators per request.</p> <p><b>Performance:</b> Processing time depends on batch size and requested data modules. Expect 5-30 seconds for typical batches.</p> <p><b>Rate Limits:</b> Limited to 10 requests per minute due to the resource-intensive nature of bulk operations.</p> 
     * @summary Bulk Indicator Enrichment (Asynchronous)
     * @param {BulkRequest} bulkRequest List of indicators and processing options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkEnrichment(bulkRequest: BulkRequest, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).bulkEnrichment(bulkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Initiates an asynchronous job to generate potential lookalike domains using default options. This GET variant is provided for convenience.</p> <p>For custom options (algorithms, limits, etc.), use the POST version of this endpoint.</p> <p>The API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when complete.</p> 
     * @summary Generate Similar Domains - GET (Asynchronous)
     * @param {string} domain The domain to generate variations for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateSimilarDomainsGet(domain: string, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).generateSimilarDomainsGet(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Initiates an asynchronous job to generate potential lookalike domains for typosquatting, homoglyph, and brand protection analysis. This is a powerful tool for proactive threat hunting.</p> <p>Because this can be a long-running process, the API immediately returns a `jobId`. Poll the `/v1/ops/jobs/{jobId}` endpoint to get the results when the job is complete.</p> <p>Use this POST version to specify custom options like algorithms, limits, or filters.</p> 
     * @summary Generate Similar Domains - POST (Asynchronous)
     * @param {string} domain The domain to generate variations for.
     * @param {SimilarDomainRequest} [similarDomainRequest] Configuration for the similarity generation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateSimilarDomainsPost(domain: string, similarDomainRequest?: SimilarDomainRequest, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).generateSimilarDomainsPost(domain, similarDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves comprehensive intelligence for a single IP address or domain. This is the primary, high-performance endpoint for synchronous enrichment.</p> <p>It aggregates data from multiple sources, including geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. Use the `include` parameter to request additional, deeper data sets that may have higher latency.</p> <h4>Performance:</h4> <ul>     <li><b>Base Response:</b> Typically under 500ms.</li>     <li><b>With `include=routing`:</b> First request may take up to 5 seconds; subsequent requests are cached for 5 minutes and respond in &lt;200ms.</li>     <li><b>With `include=ip_intelligence`:</b> Adds 200-500ms of latency for each IP address resolved from the domain.</li> </ul> 
     * @summary Enrich a Single Indicator (IP or Domain)
     * @param {GetIndicatorTypeEnum} type The type of indicator to enrich.
     * @param {string} value The value of the indicator (e.g., an IPv4/IPv6 address or a domain name).
     * @param {GetIndicatorIncludeEnum} [include] A comma-separated list of additional data modules to include in the response. Requesting more modules may increase latency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIndicator(type: GetIndicatorTypeEnum, value: string, include?: GetIndicatorIncludeEnum, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).getIndicator(type, value, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns graph visualization data showing relationships between the indicator and related infrastructure. Perfect for interactive network diagrams and threat actor infrastructure mapping.</p> <h4>Relationship Types Included:</h4> <ul>     <li><b>For Domains:</b>         <ul>             <li>Resolves to IPs</li>             <li>Shares nameservers with</li>             <li>Same SSL certificate as</li>             <li>Same registrant as</li>             <li>Links to/from other domains</li>         </ul>     </li>     <li><b>For IPs:</b>         <ul>             <li>Hosts domains</li>             <li>Same ASN as</li>             <li>Same network block as</li>             <li>Connected via routing</li>         </ul>     </li> </ul> <h4>Output Format:</h4> <p>Compatible with react-force-graph, vis.js, cytoscape.js:</p> <pre><code>{   \"nodes\": [     {\"id\": \"example.com\", \"type\": \"domain\", \"label\": \"example.com\"},     {\"id\": \"8.8.8.8\", \"type\": \"ip\", \"label\": \"8.8.8.8\"}   ],   \"links\": [     {\"source\": \"example.com\", \"target\": \"8.8.8.8\", \"type\": \"resolves_to\"}   ] }</code></pre> <h4>Performance:</h4> <ul>     <li>Response Time: 500ms-2s depending on graph complexity</li>     <li>Default: 100 nodes maximum (adjustable)</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Interactive threat actor infrastructure visualization</li>     <li>Discovering related phishing campaigns</li>     <li>Mapping shadow IT and sprawl</li>     <li>Network topology visualization</li> </ul> 
     * @summary Get Infrastructure Relationship Graph
     * @param {GetIndicatorGraphTypeEnum} type Type of indicator
     * @param {string} value The indicator value (IP address or domain)
     * @param {number} [limit] Maximum number of nodes to return in the graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIndicatorGraph(type: GetIndicatorGraphTypeEnum, value: string, limit?: number, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).getIndicatorGraph(type, value, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves time-series historical data for an IP address or domain. Track how infrastructure changes over time for threat intelligence and forensic analysis.</p> <h4>History Types:</h4> <ul>     <li><b>whois:</b> Registration history - registrant changes, expiration updates, transfers</li>     <li><b>routing:</b> BGP routing history - prefix announcements, ASN changes, route hijacks</li>     <li><b>dns:</b> DNS resolution history - IP address changes, nameserver updates</li>     <li><b>ssl:</b> Certificate history - cert replacements, CA changes, expiration events</li>     <li><b>reputation:</b> Risk score history - blacklist appearances, reputation changes</li> </ul> <h4>Data Format:</h4> <p>Timeline with dated snapshots showing what changed and when:</p> <pre><code>{   \"history\": [     {       \"timestamp\": \"2025-01-15T10:00:00Z\",       \"field\": \"registrant_company\",       \"old_value\": \"Evil Corp\",       \"new_value\": \"Legitimate LLC\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Tracking domain ownership changes</li>     <li>Investigating IP reputation degradation</li>     <li>Forensic timeline reconstruction</li>     <li>Detecting infrastructure pivots by threat actors</li> </ul> 
     * @summary Get Historical Data for Indicator
     * @param {GetIndicatorHistoryTypeEnum} type Type of indicator
     * @param {string} value The indicator value (IP address or domain)
     * @param {GetIndicatorHistoryHistoryTypeEnum} [historyType] Type of historical data to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIndicatorHistory(type: GetIndicatorHistoryTypeEnum, value: string, historyType?: GetIndicatorHistoryHistoryTypeEnum, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).getIndicatorHistory(type, value, historyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of discovered subdomains for a given root domain, based on passive DNS and other enumeration techniques.
     * @summary Get Domain Subdomains
     * @param {string} domain The root domain to query for subdomains.
     * @param {number} [limit] The maximum number of subdomains to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSubdomains(domain: string, limit?: number, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).getSubdomains(domain, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Initiates an asynchronous job to search for indicators matching specific criteria. This endpoint is extremely powerful for infrastructure discovery and threat hunting.</p> <p><b>Performance Note:</b> Searches on WHOIS fields (like `registrantCompany`) are data-intensive and can take over 50 seconds to complete. This endpoint is therefore asynchronous by design. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve results.</p> <h4>Example Search Queries:</h4> <ul>     <li>`registrantCompany:EvilCorp` - Find all domains registered by EvilCorp</li>     <li>`asn:15169` - Find all IPs in Google\'s ASN</li>     <li>`city:\"San Francisco\"` - Find all IPs geolocated to San Francisco</li> </ul> 
     * @summary Search Indicators (Asynchronous)
     * @param {SearchRequest} searchRequest The search query and configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchIndicators(searchRequest: SearchRequest, options?: RawAxiosRequestConfig) {
        return IndicatorsApiFp(this.configuration).searchIndicators(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetIndicatorTypeEnum = {
    Ip: 'ip',
    Domain: 'domain'
} as const;
export type GetIndicatorTypeEnum = typeof GetIndicatorTypeEnum[keyof typeof GetIndicatorTypeEnum];
export const GetIndicatorIncludeEnum = {
    Routing: 'routing',
    Rpki: 'rpki',
    Whois: 'whois',
    DnsDetails: 'dns_details',
    IpIntelligence: 'ip_intelligence'
} as const;
export type GetIndicatorIncludeEnum = typeof GetIndicatorIncludeEnum[keyof typeof GetIndicatorIncludeEnum];
export const GetIndicatorGraphTypeEnum = {
    Ip: 'ip',
    Domain: 'domain'
} as const;
export type GetIndicatorGraphTypeEnum = typeof GetIndicatorGraphTypeEnum[keyof typeof GetIndicatorGraphTypeEnum];
export const GetIndicatorHistoryTypeEnum = {
    Ip: 'ip',
    Domain: 'domain'
} as const;
export type GetIndicatorHistoryTypeEnum = typeof GetIndicatorHistoryTypeEnum[keyof typeof GetIndicatorHistoryTypeEnum];
export const GetIndicatorHistoryHistoryTypeEnum = {
    Whois: 'whois',
    Routing: 'routing',
    Dns: 'dns',
    Ssl: 'ssl',
    Reputation: 'reputation'
} as const;
export type GetIndicatorHistoryHistoryTypeEnum = typeof GetIndicatorHistoryHistoryTypeEnum[keyof typeof GetIndicatorHistoryHistoryTypeEnum];


/**
 * LocationApi - axios parameter creator
 */
export const LocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.</p> <h4>Request Format:</h4> <p>Send a JSON array of IP addresses (IPv4 or IPv6):</p> <pre><code>[\"8.8.8.8\", \"1.1.1.1\", \"208.67.222.222\"]</code></pre> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 500-2000ms for typical batches (10-100 IPs)</li>     <li><b>Processing:</b> Parallel lookups with automatic batching</li>     <li><b>Limit:</b> Maximum 1000 IPs per request</li>     <li><b>Rate Limit:</b> 10 requests per minute</li> </ul> <h4>Response Format:</h4> <p>Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.</p> <h4>Use Cases:</h4> <ul>     <li>Batch enrichment of access logs</li>     <li>Bulk fraud scoring</li>     <li>Geographic distribution analysis</li>     <li>Network infrastructure mapping</li> </ul> 
         * @summary Bulk IP Geolocation Lookup
         * @param {Array<string>} requestBody JSON array of IP addresses to lookup. Maximum 1000 IPs per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkIpLocation: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getBulkIpLocation', 'requestBody', requestBody)
            const localVarPath = `/v1/location/ips/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.</p> <h4>Data Included:</h4> <ul>     <li><b>Geographic:</b> Country, city, region, postal code, coordinates, timezone</li>     <li><b>Network:</b> ASN, ISP/organization name, network range</li>     <li><b>Classification:</b> Connection type (residential, datacenter, VPN, proxy, hosting)</li>     <li><b>Reputation:</b> Risk indicators and abuse scores</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> Typically &lt;150ms</li>     <li><b>Cache:</b> Results cached for 6 hours by default</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Real-time fraud detection in payment flows</li>     <li>Geographic access control and compliance</li>     <li>Bot and VPN detection</li>     <li>Threat intelligence enrichment</li> </ul> 
         * @summary Get IP Geolocation and ASN Data
         * @param {string} ip The IPv4 or IPv6 address to lookup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpLocation: async (ip: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('getIpLocation', 'ip', ip)
            const localVarPath = `/v1/location/ip/{ip}`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.</p> <h4>Statistics Included:</h4> <ul>     <li><b>Coverage:</b> Total IP addresses, networks, and ASNs covered</li>     <li><b>Geographic:</b> Number of countries, cities, and regions</li>     <li><b>Freshness:</b> Last update timestamp and update frequency</li>     <li><b>Data Sources:</b> Providers and data collection methods</li>     <li><b>Accuracy:</b> Quality metrics and confidence scores</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Verifying database coverage for your use case</li>     <li>Monitoring data freshness</li>     <li>Understanding data quality and accuracy</li> </ul> 
         * @summary Get Geolocation Database Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/location/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.</p> <h4>Supported Formats:</h4> <ul>     <li><b>IPv4 CIDR:</b> 192.168.1.0/24</li>     <li><b>IPv6 CIDR:</b> 2001:db8::/32</li> </ul> <h4>Data Included:</h4> <ul>     <li><b>Network Details:</b> CIDR range, first/last IP, total addresses</li>     <li><b>Geographic:</b> Country, city, region for the network block</li>     <li><b>Network:</b> ASN, organization, ISP information</li>     <li><b>Classification:</b> Network type and usage category</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Analyzing suspicious network ranges</li>     <li>Bulk geolocation for network blocks</li>     <li>Infrastructure mapping and reconnaissance</li> </ul> 
         * @summary Get Network/CIDR Geolocation Data
         * @param {string} network The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkLocation: async (network: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getNetworkLocation', 'network', network)
            const localVarPath = `/v1/location/network/{network}`
                .replace(`{${"network"}}`, encodeURIComponent(String(network)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.</p> <h4>Searchable Fields:</h4> <ul>     <li><b>Geographic:</b> city, country, country_code, region, postal_code, continent, continent_code</li>     <li><b>Network:</b> asn, as_number, organization, isp, isp_name</li>     <li><b>Coordinates:</b> latitude, longitude</li> </ul> <h4>Query Examples:</h4> <ul>     <li><b>Find all IPs in a city:</b> field=city&value=London</li>     <li><b>Find all IPs for an ASN:</b> field=asn&value=15169</li>     <li><b>Find all IPs for an ISP:</b> field=isp_name&value=Google</li>     <li><b>Find all IPs in country:</b> field=country_code&value=US</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 200-500ms depending on result size</li>     <li><b>Rate Limit:</b> 5 searches per minute</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Infrastructure mapping for threat actors</li>     <li>Finding all IPs in a specific region for compliance</li>     <li>Discovering VPN/proxy exit nodes</li>     <li>Threat hunting by ISP or ASN</li> </ul> 
         * @summary Search Geolocation Database by Field
         * @param {string} field The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude
         * @param {string} value The value to search for in the specified field.
         * @param {number} [limit] Maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLocation: async (field: string, value: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'field' is not null or undefined
            assertParamExists('searchLocation', 'field', field)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('searchLocation', 'value', value)
            const localVarPath = `/v1/location/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.</p> <h4>Request Format:</h4> <p>Send a JSON array of IP addresses (IPv4 or IPv6):</p> <pre><code>[\"8.8.8.8\", \"1.1.1.1\", \"208.67.222.222\"]</code></pre> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 500-2000ms for typical batches (10-100 IPs)</li>     <li><b>Processing:</b> Parallel lookups with automatic batching</li>     <li><b>Limit:</b> Maximum 1000 IPs per request</li>     <li><b>Rate Limit:</b> 10 requests per minute</li> </ul> <h4>Response Format:</h4> <p>Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.</p> <h4>Use Cases:</h4> <ul>     <li>Batch enrichment of access logs</li>     <li>Bulk fraud scoring</li>     <li>Geographic distribution analysis</li>     <li>Network infrastructure mapping</li> </ul> 
         * @summary Bulk IP Geolocation Lookup
         * @param {Array<string>} requestBody JSON array of IP addresses to lookup. Maximum 1000 IPs per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkIpLocation(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkIpLocation(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getBulkIpLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.</p> <h4>Data Included:</h4> <ul>     <li><b>Geographic:</b> Country, city, region, postal code, coordinates, timezone</li>     <li><b>Network:</b> ASN, ISP/organization name, network range</li>     <li><b>Classification:</b> Connection type (residential, datacenter, VPN, proxy, hosting)</li>     <li><b>Reputation:</b> Risk indicators and abuse scores</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> Typically &lt;150ms</li>     <li><b>Cache:</b> Results cached for 6 hours by default</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Real-time fraud detection in payment flows</li>     <li>Geographic access control and compliance</li>     <li>Bot and VPN detection</li>     <li>Threat intelligence enrichment</li> </ul> 
         * @summary Get IP Geolocation and ASN Data
         * @param {string} ip The IPv4 or IPv6 address to lookup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIpLocation(ip: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIpLocation(ip, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getIpLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.</p> <h4>Statistics Included:</h4> <ul>     <li><b>Coverage:</b> Total IP addresses, networks, and ASNs covered</li>     <li><b>Geographic:</b> Number of countries, cities, and regions</li>     <li><b>Freshness:</b> Last update timestamp and update frequency</li>     <li><b>Data Sources:</b> Providers and data collection methods</li>     <li><b>Accuracy:</b> Quality metrics and confidence scores</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Verifying database coverage for your use case</li>     <li>Monitoring data freshness</li>     <li>Understanding data quality and accuracy</li> </ul> 
         * @summary Get Geolocation Database Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocationStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocationStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getLocationStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.</p> <h4>Supported Formats:</h4> <ul>     <li><b>IPv4 CIDR:</b> 192.168.1.0/24</li>     <li><b>IPv6 CIDR:</b> 2001:db8::/32</li> </ul> <h4>Data Included:</h4> <ul>     <li><b>Network Details:</b> CIDR range, first/last IP, total addresses</li>     <li><b>Geographic:</b> Country, city, region for the network block</li>     <li><b>Network:</b> ASN, organization, ISP information</li>     <li><b>Classification:</b> Network type and usage category</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Analyzing suspicious network ranges</li>     <li>Bulk geolocation for network blocks</li>     <li>Infrastructure mapping and reconnaissance</li> </ul> 
         * @summary Get Network/CIDR Geolocation Data
         * @param {string} network The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkLocation(network: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkLocation(network, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.getNetworkLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.</p> <h4>Searchable Fields:</h4> <ul>     <li><b>Geographic:</b> city, country, country_code, region, postal_code, continent, continent_code</li>     <li><b>Network:</b> asn, as_number, organization, isp, isp_name</li>     <li><b>Coordinates:</b> latitude, longitude</li> </ul> <h4>Query Examples:</h4> <ul>     <li><b>Find all IPs in a city:</b> field=city&value=London</li>     <li><b>Find all IPs for an ASN:</b> field=asn&value=15169</li>     <li><b>Find all IPs for an ISP:</b> field=isp_name&value=Google</li>     <li><b>Find all IPs in country:</b> field=country_code&value=US</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 200-500ms depending on result size</li>     <li><b>Rate Limit:</b> 5 searches per minute</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Infrastructure mapping for threat actors</li>     <li>Finding all IPs in a specific region for compliance</li>     <li>Discovering VPN/proxy exit nodes</li>     <li>Threat hunting by ISP or ASN</li> </ul> 
         * @summary Search Geolocation Database by Field
         * @param {string} field The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude
         * @param {string} value The value to search for in the specified field.
         * @param {number} [limit] Maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLocation(field: string, value: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLocation(field, value, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationApi.searchLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationApiFp(configuration)
    return {
        /**
         * <p>Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.</p> <h4>Request Format:</h4> <p>Send a JSON array of IP addresses (IPv4 or IPv6):</p> <pre><code>[\"8.8.8.8\", \"1.1.1.1\", \"208.67.222.222\"]</code></pre> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 500-2000ms for typical batches (10-100 IPs)</li>     <li><b>Processing:</b> Parallel lookups with automatic batching</li>     <li><b>Limit:</b> Maximum 1000 IPs per request</li>     <li><b>Rate Limit:</b> 10 requests per minute</li> </ul> <h4>Response Format:</h4> <p>Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.</p> <h4>Use Cases:</h4> <ul>     <li>Batch enrichment of access logs</li>     <li>Bulk fraud scoring</li>     <li>Geographic distribution analysis</li>     <li>Network infrastructure mapping</li> </ul> 
         * @summary Bulk IP Geolocation Lookup
         * @param {Array<string>} requestBody JSON array of IP addresses to lookup. Maximum 1000 IPs per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkIpLocation(requestBody: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getBulkIpLocation(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.</p> <h4>Data Included:</h4> <ul>     <li><b>Geographic:</b> Country, city, region, postal code, coordinates, timezone</li>     <li><b>Network:</b> ASN, ISP/organization name, network range</li>     <li><b>Classification:</b> Connection type (residential, datacenter, VPN, proxy, hosting)</li>     <li><b>Reputation:</b> Risk indicators and abuse scores</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> Typically &lt;150ms</li>     <li><b>Cache:</b> Results cached for 6 hours by default</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Real-time fraud detection in payment flows</li>     <li>Geographic access control and compliance</li>     <li>Bot and VPN detection</li>     <li>Threat intelligence enrichment</li> </ul> 
         * @summary Get IP Geolocation and ASN Data
         * @param {string} ip The IPv4 or IPv6 address to lookup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpLocation(ip: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getIpLocation(ip, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.</p> <h4>Statistics Included:</h4> <ul>     <li><b>Coverage:</b> Total IP addresses, networks, and ASNs covered</li>     <li><b>Geographic:</b> Number of countries, cities, and regions</li>     <li><b>Freshness:</b> Last update timestamp and update frequency</li>     <li><b>Data Sources:</b> Providers and data collection methods</li>     <li><b>Accuracy:</b> Quality metrics and confidence scores</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Verifying database coverage for your use case</li>     <li>Monitoring data freshness</li>     <li>Understanding data quality and accuracy</li> </ul> 
         * @summary Get Geolocation Database Statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationStats(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getLocationStats(options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.</p> <h4>Supported Formats:</h4> <ul>     <li><b>IPv4 CIDR:</b> 192.168.1.0/24</li>     <li><b>IPv6 CIDR:</b> 2001:db8::/32</li> </ul> <h4>Data Included:</h4> <ul>     <li><b>Network Details:</b> CIDR range, first/last IP, total addresses</li>     <li><b>Geographic:</b> Country, city, region for the network block</li>     <li><b>Network:</b> ASN, organization, ISP information</li>     <li><b>Classification:</b> Network type and usage category</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Analyzing suspicious network ranges</li>     <li>Bulk geolocation for network blocks</li>     <li>Infrastructure mapping and reconnaissance</li> </ul> 
         * @summary Get Network/CIDR Geolocation Data
         * @param {string} network The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkLocation(network: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getNetworkLocation(network, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.</p> <h4>Searchable Fields:</h4> <ul>     <li><b>Geographic:</b> city, country, country_code, region, postal_code, continent, continent_code</li>     <li><b>Network:</b> asn, as_number, organization, isp, isp_name</li>     <li><b>Coordinates:</b> latitude, longitude</li> </ul> <h4>Query Examples:</h4> <ul>     <li><b>Find all IPs in a city:</b> field=city&value=London</li>     <li><b>Find all IPs for an ASN:</b> field=asn&value=15169</li>     <li><b>Find all IPs for an ISP:</b> field=isp_name&value=Google</li>     <li><b>Find all IPs in country:</b> field=country_code&value=US</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 200-500ms depending on result size</li>     <li><b>Rate Limit:</b> 5 searches per minute</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Infrastructure mapping for threat actors</li>     <li>Finding all IPs in a specific region for compliance</li>     <li>Discovering VPN/proxy exit nodes</li>     <li>Threat hunting by ISP or ASN</li> </ul> 
         * @summary Search Geolocation Database by Field
         * @param {string} field The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude
         * @param {string} value The value to search for in the specified field.
         * @param {number} [limit] Maximum number of results to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLocation(field: string, value: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.searchLocation(field, value, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * <p>Retrieve geolocation data for up to 1000 IP addresses in a single request. Optimized for batch processing with parallel lookups.</p> <h4>Request Format:</h4> <p>Send a JSON array of IP addresses (IPv4 or IPv6):</p> <pre><code>[\"8.8.8.8\", \"1.1.1.1\", \"208.67.222.222\"]</code></pre> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 500-2000ms for typical batches (10-100 IPs)</li>     <li><b>Processing:</b> Parallel lookups with automatic batching</li>     <li><b>Limit:</b> Maximum 1000 IPs per request</li>     <li><b>Rate Limit:</b> 10 requests per minute</li> </ul> <h4>Response Format:</h4> <p>Returns an array of geolocation objects matching the order of input IPs. Failed lookups are indicated with error objects.</p> <h4>Use Cases:</h4> <ul>     <li>Batch enrichment of access logs</li>     <li>Bulk fraud scoring</li>     <li>Geographic distribution analysis</li>     <li>Network infrastructure mapping</li> </ul> 
     * @summary Bulk IP Geolocation Lookup
     * @param {Array<string>} requestBody JSON array of IP addresses to lookup. Maximum 1000 IPs per request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBulkIpLocation(requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getBulkIpLocation(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns comprehensive geolocation and network information for any IPv4 or IPv6 address. This is one of the fastest endpoints in the API, optimized for real-time fraud detection and access control.</p> <h4>Data Included:</h4> <ul>     <li><b>Geographic:</b> Country, city, region, postal code, coordinates, timezone</li>     <li><b>Network:</b> ASN, ISP/organization name, network range</li>     <li><b>Classification:</b> Connection type (residential, datacenter, VPN, proxy, hosting)</li>     <li><b>Reputation:</b> Risk indicators and abuse scores</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> Typically &lt;150ms</li>     <li><b>Cache:</b> Results cached for 6 hours by default</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Real-time fraud detection in payment flows</li>     <li>Geographic access control and compliance</li>     <li>Bot and VPN detection</li>     <li>Threat intelligence enrichment</li> </ul> 
     * @summary Get IP Geolocation and ASN Data
     * @param {string} ip The IPv4 or IPv6 address to lookup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIpLocation(ip: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getIpLocation(ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns metadata and statistics about the geolocation database, including coverage, update frequency, and data quality metrics.</p> <h4>Statistics Included:</h4> <ul>     <li><b>Coverage:</b> Total IP addresses, networks, and ASNs covered</li>     <li><b>Geographic:</b> Number of countries, cities, and regions</li>     <li><b>Freshness:</b> Last update timestamp and update frequency</li>     <li><b>Data Sources:</b> Providers and data collection methods</li>     <li><b>Accuracy:</b> Quality metrics and confidence scores</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Verifying database coverage for your use case</li>     <li>Monitoring data freshness</li>     <li>Understanding data quality and accuracy</li> </ul> 
     * @summary Get Geolocation Database Statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLocationStats(options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getLocationStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Returns geolocation and network information for an entire network range specified in CIDR notation. Useful for analyzing network blocks, ranges, and subnets.</p> <h4>Supported Formats:</h4> <ul>     <li><b>IPv4 CIDR:</b> 192.168.1.0/24</li>     <li><b>IPv6 CIDR:</b> 2001:db8::/32</li> </ul> <h4>Data Included:</h4> <ul>     <li><b>Network Details:</b> CIDR range, first/last IP, total addresses</li>     <li><b>Geographic:</b> Country, city, region for the network block</li>     <li><b>Network:</b> ASN, organization, ISP information</li>     <li><b>Classification:</b> Network type and usage category</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Analyzing suspicious network ranges</li>     <li>Bulk geolocation for network blocks</li>     <li>Infrastructure mapping and reconnaissance</li> </ul> 
     * @summary Get Network/CIDR Geolocation Data
     * @param {string} network The network range in CIDR notation (e.g., 192.168.1.0/24 or 2001:db8::/32).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getNetworkLocation(network: string, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).getNetworkLocation(network, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Search the geolocation database by specific fields to find all IP addresses matching your criteria. Powerful for threat hunting, infrastructure discovery, and pattern analysis.</p> <h4>Searchable Fields:</h4> <ul>     <li><b>Geographic:</b> city, country, country_code, region, postal_code, continent, continent_code</li>     <li><b>Network:</b> asn, as_number, organization, isp, isp_name</li>     <li><b>Coordinates:</b> latitude, longitude</li> </ul> <h4>Query Examples:</h4> <ul>     <li><b>Find all IPs in a city:</b> field=city&value=London</li>     <li><b>Find all IPs for an ASN:</b> field=asn&value=15169</li>     <li><b>Find all IPs for an ISP:</b> field=isp_name&value=Google</li>     <li><b>Find all IPs in country:</b> field=country_code&value=US</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Response Time:</b> 200-500ms depending on result size</li>     <li><b>Rate Limit:</b> 5 searches per minute</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Infrastructure mapping for threat actors</li>     <li>Finding all IPs in a specific region for compliance</li>     <li>Discovering VPN/proxy exit nodes</li>     <li>Threat hunting by ISP or ASN</li> </ul> 
     * @summary Search Geolocation Database by Field
     * @param {string} field The field to search. Valid fields: city, country, country_code, isp_name, isp, asn, as_number, organization, continent, continent_code, region, postal_code, latitude, longitude
     * @param {string} value The value to search for in the specified field.
     * @param {number} [limit] Maximum number of results to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchLocation(field: string, value: string, limit?: number, options?: RawAxiosRequestConfig) {
        return LocationApiFp(this.configuration).searchLocation(field, value, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperationsApi - axios parameter creator
 */
export const OperationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Creates a comprehensive map of infrastructure relationships starting from a domain or IP. Discovers connected assets through shared hosting, DNS, certificates, and network relationships.</p> <h4>Mapping Depth Levels:</h4> <ul>     <li><b>Depth 1:</b> Direct relationships only (~30 seconds, 10-50 assets)</li>     <li><b>Depth 2:</b> 2 hops out (~2-5 minutes, 50-500 assets)</li>     <li><b>Depth 3:</b> 3 hops out (~10-30 minutes, 500-5000 assets)</li> </ul> <h4>Relationship Types Discovered:</h4> <ul>     <li>Domains on same IP</li>     <li>Domains sharing nameservers</li>     <li>Domains with same SSL certificate</li>     <li>IPs in same ASN</li>     <li>Domains with same registrant</li> </ul> <h4>Output Format:</h4> <p>Results returned as graph data compatible with visualization libraries (nodes and edges).</p> <h4>Use Cases:</h4> <ul>     <li>Threat actor infrastructure mapping</li>     <li>Discovering related phishing domains</li>     <li>Finding shadow IT and forgotten assets</li> </ul> 
         * @summary Map Infrastructure Relationships (Asynchronous)
         * @param {object} body Mapping configuration. Example: &#x60;&#x60;&#x60;json {   \&quot;startPoint\&quot;: \&quot;example.com\&quot;,   \&quot;depth\&quot;: 2 } &#x60;&#x60;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInfrastructureMap: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createInfrastructureMap', 'body', body)
            const localVarPath = `/v1/ops/map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Initiates a comprehensive security scan of a domain\'s infrastructure. Performs reconnaissance, port scanning, service detection, and vulnerability assessment.</p> <h4>Scan Types:</h4> <ul>     <li><b>comprehensive:</b> Full scan including all modules (recommended for complete assessment)</li>     <li><b>subdomains:</b> Subdomain enumeration only</li>     <li><b>ports:</b> Port scanning and service detection</li>     <li><b>technologies:</b> Technology stack detection</li>     <li><b>vulnerabilities:</b> Known vulnerability checks</li>     <li><b>ssl:</b> SSL/TLS configuration and certificate analysis</li>     <li><b>dns:</b> DNS configuration and zone transfer tests</li>     <li><b>whois:</b> Registration and ownership information</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Quick scans:</b> 30-60 seconds (subdomains, dns, whois)</li>     <li><b>Comprehensive scan:</b> 5-15 minutes depending on infrastructure size</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Pre-engagement reconnaissance for penetration testing</li>     <li>Attack surface assessment</li>     <li>Infrastructure inventory and mapping</li>     <li>Vulnerability management</li> </ul> 
         * @summary Infrastructure Security Scan (Asynchronous)
         * @param {InfraScanRequest} infraScanRequest Scan configuration including target domain and scan type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInfrastructureScan: async (infraScanRequest: InfraScanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'infraScanRequest' is not null or undefined
            assertParamExists('createInfrastructureScan', 'infraScanRequest', infraScanRequest)
            const localVarPath = `/v1/ops/scan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(infraScanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Create alert rules for a monitored asset. Get notified via webhook, email, or Slack when specific conditions are met.</p> <h4>Alert Types:</h4> <ul>     <li><b>downtime:</b> Site becomes unreachable</li>     <li><b>dns_change:</b> DNS records modified</li>     <li><b>whois_change:</b> Registration details updated</li>     <li><b>ssl_expiring:</b> Certificate expires soon (7, 14, 30 days)</li>     <li><b>content_change:</b> Page content modified</li>     <li><b>technology_change:</b> Tech stack changes detected</li> </ul> <h4>Notification Channels:</h4> <ul>     <li>Webhook (POST to your endpoint)</li>     <li>Email</li>     <li>Slack</li>     <li>PagerDuty</li> </ul> <h4>Example Configuration:</h4> <pre><code>{   \"type\": \"ssl_expiring\",   \"threshold_days\": 14,   \"channels\": [\"email\", \"slack\"],   \"email\": \"alerts@example.com\",   \"slack_webhook\": \"https://hooks.slack.com/...\" }</code></pre> 
         * @summary Configure Monitoring Alerts (Asynchronous)
         * @param {string} target The domain or IP address to configure alerts for.
         * @param {object} body Alert configuration including type, thresholds, and notification channels.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMonitoringAlert: async (target: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'target' is not null or undefined
            assertParamExists('createMonitoringAlert', 'target', target)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createMonitoringAlert', 'body', body)
            const localVarPath = `/v1/ops/monitor/{target}/alert`
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Initiates an asynchronous job to capture a screenshot of a website. Supports various viewport sizes, full-page captures, and JavaScript rendering.</p> <p><b>Performance Note:</b> A typical screenshot capture takes 10-30 seconds. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve the URL of the final image.</p> <p><b>Output:</b> The job result will contain a URL to download the screenshot image in the specified format (PNG, JPEG, or WebP).</p> 
         * @summary Capture a Website Screenshot (Asynchronous)
         * @param {ScreenshotRequest} screenshotRequest The URL and options for the screenshot capture.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreenshot: async (screenshotRequest: ScreenshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'screenshotRequest' is not null or undefined
            assertParamExists('createScreenshot', 'screenshotRequest', screenshotRequest)
            const localVarPath = `/v1/ops/screenshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(screenshotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves detected changes in infrastructure configuration for a domain or IP over time. Essential for security monitoring and compliance auditing.</p> <h4>Change Types Tracked:</h4> <ul>     <li><b>dns:</b> A, AAAA, MX, NS, TXT record changes</li>     <li><b>whois:</b> Registrant, registrar, nameserver changes</li>     <li><b>ssl:</b> Certificate replacements and expirations</li>     <li><b>ip:</b> IP address changes for domains</li>     <li><b>content:</b> Homepage content modifications</li>     <li><b>technology:</b> Tech stack changes</li> </ul> <h4>Response Format:</h4> <p>Timeline of changes with before/after values:</p> <pre><code>{   \"changes\": [     {       \"timestamp\": \"2025-01-15T10:30:00Z\",       \"type\": \"dns\",       \"field\": \"A_RECORD\",       \"old_value\": \"8.8.8.8\",       \"new_value\": \"1.1.1.1\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Security incident investigation</li>     <li>Compliance and audit trails</li>     <li>Detecting unauthorized changes</li>     <li>Infrastructure change management</li> </ul> 
         * @summary Get Infrastructure Change History
         * @param {string} target The domain or IP address to check for changes.
         * @param {GetChangeDetectionTypeEnum} [type] Type of changes to retrieve.
         * @param {string} [since] ISO 8601 timestamp to retrieve changes from. Omit to get all changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeDetection: async (target: string, type?: GetChangeDetectionTypeEnum, since?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getChangeDetection', 'target', target)
            const localVarPath = `/v1/ops/changes/{target}`
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves the current status and results of an asynchronous job. Poll this endpoint to check job progress.</p> <h4>Polling Recommendations:</h4> <ul>     <li>For fast jobs (e.g., similar domains), poll every 1-2 seconds.</li>     <li>For slow jobs (e.g., WHOIS search, screenshots), poll every 5-10 seconds.</li>     <li>Implement an exponential backoff strategy for very long-running jobs.</li>     <li>Stop polling when the status is `COMPLETED`, `FAILED`, or `CANCELLED`.</li> </ul> <h4>Job Statuses:</h4> <ul>     <li><b>PENDING:</b> Job is queued and waiting to start.</li>     <li><b>PROCESSING:</b> Job is actively being processed.</li>     <li><b>COMPLETED:</b> Job finished successfully, results are available.</li>     <li><b>FAILED:</b> Job failed with an error.</li>     <li><b>CANCELLED:</b> Job was cancelled by user or system.</li> </ul> 
         * @summary Get Asynchronous Job Status and Results
         * @param {string} jobId The unique ID of the job, returned from a &#x60;POST&#x60; operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJob', 'jobId', jobId)
            const localVarPath = `/v1/ops/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieves current monitoring configuration and historical metrics for a domain or IP address.</p> <h4>Status Information:</h4> <ul>     <li><b>Monitoring State:</b> Active, paused, or not monitored</li>     <li><b>Check Frequency:</b> How often checks are performed</li>     <li><b>Active Alerts:</b> Currently triggered alert conditions</li>     <li><b>Last Check:</b> Timestamp of most recent check</li> </ul> <h4>Metrics Included:</h4> <ul>     <li>Uptime percentage (last 30 days)</li>     <li>Average response time</li>     <li>SSL certificate expiration countdown</li>     <li>DNS change events</li>     <li>WHOIS change events</li> </ul> 
         * @summary Get Monitoring Status and Metrics
         * @param {string} target The domain or IP address to check monitoring status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoringStatus: async (target: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getMonitoringStatus', 'target', target)
            const localVarPath = `/v1/ops/monitor/{target}`
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Retrieve all previously captured screenshots for a specific URL, ordered by capture time (newest first). Includes download URLs and metadata for each capture.</p> <h4>Response Includes:</h4> <ul>     <li><b>Download URL:</b> Direct link to screenshot image</li>     <li><b>Capture Time:</b> Timestamp when screenshot was taken</li>     <li><b>Dimensions:</b> Image width and height</li>     <li><b>Format:</b> Image format (PNG, JPEG, WebP)</li>     <li><b>File Size:</b> Size in bytes</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Review website evolution over time</li>     <li>Compare screenshots for change detection</li>     <li>Download historical screenshots for reporting</li> </ul> 
         * @summary Get Screenshot History
         * @param {string} url The URL to retrieve screenshot history for.
         * @param {number} [limit] Maximum number of screenshots to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenshotHistory: async (url: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'url' is not null or undefined
            assertParamExists('getScreenshotHistory', 'url', url)
            const localVarPath = `/v1/ops/screenshot/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Create a recurring job to capture website screenshots at regular intervals. Essential for monitoring website changes, detecting defacements, and tracking competitor updates.</p> <h4>Schedule Options:</h4> <ul>     <li><b>Cron Expression:</b> Full cron syntax support (e.g., `0 0 * * * *` = hourly)</li>     <li><b>Frequency Presets:</b> hourly, daily, weekly, monthly</li>     <li><b>Timezone:</b> Specify timezone for accurate scheduling</li>     <li><b>Retention:</b> Auto-cleanup old screenshots (default: keep last 30)</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Setup Time:</b> ~2 seconds to create schedule</li>     <li><b>Screenshot Time:</b> 10-30 seconds per capture</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Automated defacement detection</li>     <li>Compliance monitoring and archival</li>     <li>Competitor website tracking</li>     <li>Visual regression testing</li> </ul> 
         * @summary Schedule Recurring Screenshots (Asynchronous)
         * @param {ScreenshotRequest} screenshotRequest Schedule configuration including URL, schedule timing, and screenshot options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleScreenshot: async (screenshotRequest: ScreenshotRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'screenshotRequest' is not null or undefined
            assertParamExists('scheduleScreenshot', 'screenshotRequest', screenshotRequest)
            const localVarPath = `/v1/ops/screenshot/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(screenshotRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsApi - functional programming interface
 */
export const OperationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Creates a comprehensive map of infrastructure relationships starting from a domain or IP. Discovers connected assets through shared hosting, DNS, certificates, and network relationships.</p> <h4>Mapping Depth Levels:</h4> <ul>     <li><b>Depth 1:</b> Direct relationships only (~30 seconds, 10-50 assets)</li>     <li><b>Depth 2:</b> 2 hops out (~2-5 minutes, 50-500 assets)</li>     <li><b>Depth 3:</b> 3 hops out (~10-30 minutes, 500-5000 assets)</li> </ul> <h4>Relationship Types Discovered:</h4> <ul>     <li>Domains on same IP</li>     <li>Domains sharing nameservers</li>     <li>Domains with same SSL certificate</li>     <li>IPs in same ASN</li>     <li>Domains with same registrant</li> </ul> <h4>Output Format:</h4> <p>Results returned as graph data compatible with visualization libraries (nodes and edges).</p> <h4>Use Cases:</h4> <ul>     <li>Threat actor infrastructure mapping</li>     <li>Discovering related phishing domains</li>     <li>Finding shadow IT and forgotten assets</li> </ul> 
         * @summary Map Infrastructure Relationships (Asynchronous)
         * @param {object} body Mapping configuration. Example: &#x60;&#x60;&#x60;json {   \&quot;startPoint\&quot;: \&quot;example.com\&quot;,   \&quot;depth\&quot;: 2 } &#x60;&#x60;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInfrastructureMap(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInfrastructureMap(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.createInfrastructureMap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Initiates a comprehensive security scan of a domain\'s infrastructure. Performs reconnaissance, port scanning, service detection, and vulnerability assessment.</p> <h4>Scan Types:</h4> <ul>     <li><b>comprehensive:</b> Full scan including all modules (recommended for complete assessment)</li>     <li><b>subdomains:</b> Subdomain enumeration only</li>     <li><b>ports:</b> Port scanning and service detection</li>     <li><b>technologies:</b> Technology stack detection</li>     <li><b>vulnerabilities:</b> Known vulnerability checks</li>     <li><b>ssl:</b> SSL/TLS configuration and certificate analysis</li>     <li><b>dns:</b> DNS configuration and zone transfer tests</li>     <li><b>whois:</b> Registration and ownership information</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Quick scans:</b> 30-60 seconds (subdomains, dns, whois)</li>     <li><b>Comprehensive scan:</b> 5-15 minutes depending on infrastructure size</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Pre-engagement reconnaissance for penetration testing</li>     <li>Attack surface assessment</li>     <li>Infrastructure inventory and mapping</li>     <li>Vulnerability management</li> </ul> 
         * @summary Infrastructure Security Scan (Asynchronous)
         * @param {InfraScanRequest} infraScanRequest Scan configuration including target domain and scan type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInfrastructureScan(infraScanRequest: InfraScanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInfrastructureScan(infraScanRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.createInfrastructureScan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Create alert rules for a monitored asset. Get notified via webhook, email, or Slack when specific conditions are met.</p> <h4>Alert Types:</h4> <ul>     <li><b>downtime:</b> Site becomes unreachable</li>     <li><b>dns_change:</b> DNS records modified</li>     <li><b>whois_change:</b> Registration details updated</li>     <li><b>ssl_expiring:</b> Certificate expires soon (7, 14, 30 days)</li>     <li><b>content_change:</b> Page content modified</li>     <li><b>technology_change:</b> Tech stack changes detected</li> </ul> <h4>Notification Channels:</h4> <ul>     <li>Webhook (POST to your endpoint)</li>     <li>Email</li>     <li>Slack</li>     <li>PagerDuty</li> </ul> <h4>Example Configuration:</h4> <pre><code>{   \"type\": \"ssl_expiring\",   \"threshold_days\": 14,   \"channels\": [\"email\", \"slack\"],   \"email\": \"alerts@example.com\",   \"slack_webhook\": \"https://hooks.slack.com/...\" }</code></pre> 
         * @summary Configure Monitoring Alerts (Asynchronous)
         * @param {string} target The domain or IP address to configure alerts for.
         * @param {object} body Alert configuration including type, thresholds, and notification channels.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMonitoringAlert(target: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMonitoringAlert(target, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.createMonitoringAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Initiates an asynchronous job to capture a screenshot of a website. Supports various viewport sizes, full-page captures, and JavaScript rendering.</p> <p><b>Performance Note:</b> A typical screenshot capture takes 10-30 seconds. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve the URL of the final image.</p> <p><b>Output:</b> The job result will contain a URL to download the screenshot image in the specified format (PNG, JPEG, or WebP).</p> 
         * @summary Capture a Website Screenshot (Asynchronous)
         * @param {ScreenshotRequest} screenshotRequest The URL and options for the screenshot capture.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreenshot(screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreenshot(screenshotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.createScreenshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves detected changes in infrastructure configuration for a domain or IP over time. Essential for security monitoring and compliance auditing.</p> <h4>Change Types Tracked:</h4> <ul>     <li><b>dns:</b> A, AAAA, MX, NS, TXT record changes</li>     <li><b>whois:</b> Registrant, registrar, nameserver changes</li>     <li><b>ssl:</b> Certificate replacements and expirations</li>     <li><b>ip:</b> IP address changes for domains</li>     <li><b>content:</b> Homepage content modifications</li>     <li><b>technology:</b> Tech stack changes</li> </ul> <h4>Response Format:</h4> <p>Timeline of changes with before/after values:</p> <pre><code>{   \"changes\": [     {       \"timestamp\": \"2025-01-15T10:30:00Z\",       \"type\": \"dns\",       \"field\": \"A_RECORD\",       \"old_value\": \"8.8.8.8\",       \"new_value\": \"1.1.1.1\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Security incident investigation</li>     <li>Compliance and audit trails</li>     <li>Detecting unauthorized changes</li>     <li>Infrastructure change management</li> </ul> 
         * @summary Get Infrastructure Change History
         * @param {string} target The domain or IP address to check for changes.
         * @param {GetChangeDetectionTypeEnum} [type] Type of changes to retrieve.
         * @param {string} [since] ISO 8601 timestamp to retrieve changes from. Omit to get all changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChangeDetection(target: string, type?: GetChangeDetectionTypeEnum, since?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChangeDetection(target, type, since, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.getChangeDetection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves the current status and results of an asynchronous job. Poll this endpoint to check job progress.</p> <h4>Polling Recommendations:</h4> <ul>     <li>For fast jobs (e.g., similar domains), poll every 1-2 seconds.</li>     <li>For slow jobs (e.g., WHOIS search, screenshots), poll every 5-10 seconds.</li>     <li>Implement an exponential backoff strategy for very long-running jobs.</li>     <li>Stop polling when the status is `COMPLETED`, `FAILED`, or `CANCELLED`.</li> </ul> <h4>Job Statuses:</h4> <ul>     <li><b>PENDING:</b> Job is queued and waiting to start.</li>     <li><b>PROCESSING:</b> Job is actively being processed.</li>     <li><b>COMPLETED:</b> Job finished successfully, results are available.</li>     <li><b>FAILED:</b> Job failed with an error.</li>     <li><b>CANCELLED:</b> Job was cancelled by user or system.</li> </ul> 
         * @summary Get Asynchronous Job Status and Results
         * @param {string} jobId The unique ID of the job, returned from a &#x60;POST&#x60; operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJob(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJob(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.getJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieves current monitoring configuration and historical metrics for a domain or IP address.</p> <h4>Status Information:</h4> <ul>     <li><b>Monitoring State:</b> Active, paused, or not monitored</li>     <li><b>Check Frequency:</b> How often checks are performed</li>     <li><b>Active Alerts:</b> Currently triggered alert conditions</li>     <li><b>Last Check:</b> Timestamp of most recent check</li> </ul> <h4>Metrics Included:</h4> <ul>     <li>Uptime percentage (last 30 days)</li>     <li>Average response time</li>     <li>SSL certificate expiration countdown</li>     <li>DNS change events</li>     <li>WHOIS change events</li> </ul> 
         * @summary Get Monitoring Status and Metrics
         * @param {string} target The domain or IP address to check monitoring status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitoringStatus(target: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitoringStatus(target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.getMonitoringStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Retrieve all previously captured screenshots for a specific URL, ordered by capture time (newest first). Includes download URLs and metadata for each capture.</p> <h4>Response Includes:</h4> <ul>     <li><b>Download URL:</b> Direct link to screenshot image</li>     <li><b>Capture Time:</b> Timestamp when screenshot was taken</li>     <li><b>Dimensions:</b> Image width and height</li>     <li><b>Format:</b> Image format (PNG, JPEG, WebP)</li>     <li><b>File Size:</b> Size in bytes</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Review website evolution over time</li>     <li>Compare screenshots for change detection</li>     <li>Download historical screenshots for reporting</li> </ul> 
         * @summary Get Screenshot History
         * @param {string} url The URL to retrieve screenshot history for.
         * @param {number} [limit] Maximum number of screenshots to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScreenshotHistory(url: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScreenshotHistory(url, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.getScreenshotHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Create a recurring job to capture website screenshots at regular intervals. Essential for monitoring website changes, detecting defacements, and tracking competitor updates.</p> <h4>Schedule Options:</h4> <ul>     <li><b>Cron Expression:</b> Full cron syntax support (e.g., `0 0 * * * *` = hourly)</li>     <li><b>Frequency Presets:</b> hourly, daily, weekly, monthly</li>     <li><b>Timezone:</b> Specify timezone for accurate scheduling</li>     <li><b>Retention:</b> Auto-cleanup old screenshots (default: keep last 30)</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Setup Time:</b> ~2 seconds to create schedule</li>     <li><b>Screenshot Time:</b> 10-30 seconds per capture</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Automated defacement detection</li>     <li>Compliance monitoring and archival</li>     <li>Competitor website tracking</li>     <li>Visual regression testing</li> </ul> 
         * @summary Schedule Recurring Screenshots (Asynchronous)
         * @param {ScreenshotRequest} screenshotRequest Schedule configuration including URL, schedule timing, and screenshot options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleScreenshot(screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleScreenshot(screenshotRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperationsApi.scheduleScreenshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperationsApi - factory interface
 */
export const OperationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationsApiFp(configuration)
    return {
        /**
         * <p>Creates a comprehensive map of infrastructure relationships starting from a domain or IP. Discovers connected assets through shared hosting, DNS, certificates, and network relationships.</p> <h4>Mapping Depth Levels:</h4> <ul>     <li><b>Depth 1:</b> Direct relationships only (~30 seconds, 10-50 assets)</li>     <li><b>Depth 2:</b> 2 hops out (~2-5 minutes, 50-500 assets)</li>     <li><b>Depth 3:</b> 3 hops out (~10-30 minutes, 500-5000 assets)</li> </ul> <h4>Relationship Types Discovered:</h4> <ul>     <li>Domains on same IP</li>     <li>Domains sharing nameservers</li>     <li>Domains with same SSL certificate</li>     <li>IPs in same ASN</li>     <li>Domains with same registrant</li> </ul> <h4>Output Format:</h4> <p>Results returned as graph data compatible with visualization libraries (nodes and edges).</p> <h4>Use Cases:</h4> <ul>     <li>Threat actor infrastructure mapping</li>     <li>Discovering related phishing domains</li>     <li>Finding shadow IT and forgotten assets</li> </ul> 
         * @summary Map Infrastructure Relationships (Asynchronous)
         * @param {object} body Mapping configuration. Example: &#x60;&#x60;&#x60;json {   \&quot;startPoint\&quot;: \&quot;example.com\&quot;,   \&quot;depth\&quot;: 2 } &#x60;&#x60;&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInfrastructureMap(body: object, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createInfrastructureMap(body, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Initiates a comprehensive security scan of a domain\'s infrastructure. Performs reconnaissance, port scanning, service detection, and vulnerability assessment.</p> <h4>Scan Types:</h4> <ul>     <li><b>comprehensive:</b> Full scan including all modules (recommended for complete assessment)</li>     <li><b>subdomains:</b> Subdomain enumeration only</li>     <li><b>ports:</b> Port scanning and service detection</li>     <li><b>technologies:</b> Technology stack detection</li>     <li><b>vulnerabilities:</b> Known vulnerability checks</li>     <li><b>ssl:</b> SSL/TLS configuration and certificate analysis</li>     <li><b>dns:</b> DNS configuration and zone transfer tests</li>     <li><b>whois:</b> Registration and ownership information</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Quick scans:</b> 30-60 seconds (subdomains, dns, whois)</li>     <li><b>Comprehensive scan:</b> 5-15 minutes depending on infrastructure size</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Pre-engagement reconnaissance for penetration testing</li>     <li>Attack surface assessment</li>     <li>Infrastructure inventory and mapping</li>     <li>Vulnerability management</li> </ul> 
         * @summary Infrastructure Security Scan (Asynchronous)
         * @param {InfraScanRequest} infraScanRequest Scan configuration including target domain and scan type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInfrastructureScan(infraScanRequest: InfraScanRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createInfrastructureScan(infraScanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Create alert rules for a monitored asset. Get notified via webhook, email, or Slack when specific conditions are met.</p> <h4>Alert Types:</h4> <ul>     <li><b>downtime:</b> Site becomes unreachable</li>     <li><b>dns_change:</b> DNS records modified</li>     <li><b>whois_change:</b> Registration details updated</li>     <li><b>ssl_expiring:</b> Certificate expires soon (7, 14, 30 days)</li>     <li><b>content_change:</b> Page content modified</li>     <li><b>technology_change:</b> Tech stack changes detected</li> </ul> <h4>Notification Channels:</h4> <ul>     <li>Webhook (POST to your endpoint)</li>     <li>Email</li>     <li>Slack</li>     <li>PagerDuty</li> </ul> <h4>Example Configuration:</h4> <pre><code>{   \"type\": \"ssl_expiring\",   \"threshold_days\": 14,   \"channels\": [\"email\", \"slack\"],   \"email\": \"alerts@example.com\",   \"slack_webhook\": \"https://hooks.slack.com/...\" }</code></pre> 
         * @summary Configure Monitoring Alerts (Asynchronous)
         * @param {string} target The domain or IP address to configure alerts for.
         * @param {object} body Alert configuration including type, thresholds, and notification channels.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMonitoringAlert(target: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createMonitoringAlert(target, body, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Initiates an asynchronous job to capture a screenshot of a website. Supports various viewport sizes, full-page captures, and JavaScript rendering.</p> <p><b>Performance Note:</b> A typical screenshot capture takes 10-30 seconds. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve the URL of the final image.</p> <p><b>Output:</b> The job result will contain a URL to download the screenshot image in the specified format (PNG, JPEG, or WebP).</p> 
         * @summary Capture a Website Screenshot (Asynchronous)
         * @param {ScreenshotRequest} screenshotRequest The URL and options for the screenshot capture.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreenshot(screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createScreenshot(screenshotRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves detected changes in infrastructure configuration for a domain or IP over time. Essential for security monitoring and compliance auditing.</p> <h4>Change Types Tracked:</h4> <ul>     <li><b>dns:</b> A, AAAA, MX, NS, TXT record changes</li>     <li><b>whois:</b> Registrant, registrar, nameserver changes</li>     <li><b>ssl:</b> Certificate replacements and expirations</li>     <li><b>ip:</b> IP address changes for domains</li>     <li><b>content:</b> Homepage content modifications</li>     <li><b>technology:</b> Tech stack changes</li> </ul> <h4>Response Format:</h4> <p>Timeline of changes with before/after values:</p> <pre><code>{   \"changes\": [     {       \"timestamp\": \"2025-01-15T10:30:00Z\",       \"type\": \"dns\",       \"field\": \"A_RECORD\",       \"old_value\": \"8.8.8.8\",       \"new_value\": \"1.1.1.1\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Security incident investigation</li>     <li>Compliance and audit trails</li>     <li>Detecting unauthorized changes</li>     <li>Infrastructure change management</li> </ul> 
         * @summary Get Infrastructure Change History
         * @param {string} target The domain or IP address to check for changes.
         * @param {GetChangeDetectionTypeEnum} [type] Type of changes to retrieve.
         * @param {string} [since] ISO 8601 timestamp to retrieve changes from. Omit to get all changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeDetection(target: string, type?: GetChangeDetectionTypeEnum, since?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getChangeDetection(target, type, since, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves the current status and results of an asynchronous job. Poll this endpoint to check job progress.</p> <h4>Polling Recommendations:</h4> <ul>     <li>For fast jobs (e.g., similar domains), poll every 1-2 seconds.</li>     <li>For slow jobs (e.g., WHOIS search, screenshots), poll every 5-10 seconds.</li>     <li>Implement an exponential backoff strategy for very long-running jobs.</li>     <li>Stop polling when the status is `COMPLETED`, `FAILED`, or `CANCELLED`.</li> </ul> <h4>Job Statuses:</h4> <ul>     <li><b>PENDING:</b> Job is queued and waiting to start.</li>     <li><b>PROCESSING:</b> Job is actively being processed.</li>     <li><b>COMPLETED:</b> Job finished successfully, results are available.</li>     <li><b>FAILED:</b> Job failed with an error.</li>     <li><b>CANCELLED:</b> Job was cancelled by user or system.</li> </ul> 
         * @summary Get Asynchronous Job Status and Results
         * @param {string} jobId The unique ID of the job, returned from a &#x60;POST&#x60; operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJob(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<Job> {
            return localVarFp.getJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieves current monitoring configuration and historical metrics for a domain or IP address.</p> <h4>Status Information:</h4> <ul>     <li><b>Monitoring State:</b> Active, paused, or not monitored</li>     <li><b>Check Frequency:</b> How often checks are performed</li>     <li><b>Active Alerts:</b> Currently triggered alert conditions</li>     <li><b>Last Check:</b> Timestamp of most recent check</li> </ul> <h4>Metrics Included:</h4> <ul>     <li>Uptime percentage (last 30 days)</li>     <li>Average response time</li>     <li>SSL certificate expiration countdown</li>     <li>DNS change events</li>     <li>WHOIS change events</li> </ul> 
         * @summary Get Monitoring Status and Metrics
         * @param {string} target The domain or IP address to check monitoring status for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoringStatus(target: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getMonitoringStatus(target, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Retrieve all previously captured screenshots for a specific URL, ordered by capture time (newest first). Includes download URLs and metadata for each capture.</p> <h4>Response Includes:</h4> <ul>     <li><b>Download URL:</b> Direct link to screenshot image</li>     <li><b>Capture Time:</b> Timestamp when screenshot was taken</li>     <li><b>Dimensions:</b> Image width and height</li>     <li><b>Format:</b> Image format (PNG, JPEG, WebP)</li>     <li><b>File Size:</b> Size in bytes</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Review website evolution over time</li>     <li>Compare screenshots for change detection</li>     <li>Download historical screenshots for reporting</li> </ul> 
         * @summary Get Screenshot History
         * @param {string} url The URL to retrieve screenshot history for.
         * @param {number} [limit] Maximum number of screenshots to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScreenshotHistory(url: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getScreenshotHistory(url, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Create a recurring job to capture website screenshots at regular intervals. Essential for monitoring website changes, detecting defacements, and tracking competitor updates.</p> <h4>Schedule Options:</h4> <ul>     <li><b>Cron Expression:</b> Full cron syntax support (e.g., `0 0 * * * *` = hourly)</li>     <li><b>Frequency Presets:</b> hourly, daily, weekly, monthly</li>     <li><b>Timezone:</b> Specify timezone for accurate scheduling</li>     <li><b>Retention:</b> Auto-cleanup old screenshots (default: keep last 30)</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Setup Time:</b> ~2 seconds to create schedule</li>     <li><b>Screenshot Time:</b> 10-30 seconds per capture</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Automated defacement detection</li>     <li>Compliance monitoring and archival</li>     <li>Competitor website tracking</li>     <li>Visual regression testing</li> </ul> 
         * @summary Schedule Recurring Screenshots (Asynchronous)
         * @param {ScreenshotRequest} screenshotRequest Schedule configuration including URL, schedule timing, and screenshot options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleScreenshot(screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.scheduleScreenshot(screenshotRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationsApi - object-oriented interface
 */
export class OperationsApi extends BaseAPI {
    /**
     * <p>Creates a comprehensive map of infrastructure relationships starting from a domain or IP. Discovers connected assets through shared hosting, DNS, certificates, and network relationships.</p> <h4>Mapping Depth Levels:</h4> <ul>     <li><b>Depth 1:</b> Direct relationships only (~30 seconds, 10-50 assets)</li>     <li><b>Depth 2:</b> 2 hops out (~2-5 minutes, 50-500 assets)</li>     <li><b>Depth 3:</b> 3 hops out (~10-30 minutes, 500-5000 assets)</li> </ul> <h4>Relationship Types Discovered:</h4> <ul>     <li>Domains on same IP</li>     <li>Domains sharing nameservers</li>     <li>Domains with same SSL certificate</li>     <li>IPs in same ASN</li>     <li>Domains with same registrant</li> </ul> <h4>Output Format:</h4> <p>Results returned as graph data compatible with visualization libraries (nodes and edges).</p> <h4>Use Cases:</h4> <ul>     <li>Threat actor infrastructure mapping</li>     <li>Discovering related phishing domains</li>     <li>Finding shadow IT and forgotten assets</li> </ul> 
     * @summary Map Infrastructure Relationships (Asynchronous)
     * @param {object} body Mapping configuration. Example: &#x60;&#x60;&#x60;json {   \&quot;startPoint\&quot;: \&quot;example.com\&quot;,   \&quot;depth\&quot;: 2 } &#x60;&#x60;&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createInfrastructureMap(body: object, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).createInfrastructureMap(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Initiates a comprehensive security scan of a domain\'s infrastructure. Performs reconnaissance, port scanning, service detection, and vulnerability assessment.</p> <h4>Scan Types:</h4> <ul>     <li><b>comprehensive:</b> Full scan including all modules (recommended for complete assessment)</li>     <li><b>subdomains:</b> Subdomain enumeration only</li>     <li><b>ports:</b> Port scanning and service detection</li>     <li><b>technologies:</b> Technology stack detection</li>     <li><b>vulnerabilities:</b> Known vulnerability checks</li>     <li><b>ssl:</b> SSL/TLS configuration and certificate analysis</li>     <li><b>dns:</b> DNS configuration and zone transfer tests</li>     <li><b>whois:</b> Registration and ownership information</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Quick scans:</b> 30-60 seconds (subdomains, dns, whois)</li>     <li><b>Comprehensive scan:</b> 5-15 minutes depending on infrastructure size</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Pre-engagement reconnaissance for penetration testing</li>     <li>Attack surface assessment</li>     <li>Infrastructure inventory and mapping</li>     <li>Vulnerability management</li> </ul> 
     * @summary Infrastructure Security Scan (Asynchronous)
     * @param {InfraScanRequest} infraScanRequest Scan configuration including target domain and scan type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createInfrastructureScan(infraScanRequest: InfraScanRequest, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).createInfrastructureScan(infraScanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Create alert rules for a monitored asset. Get notified via webhook, email, or Slack when specific conditions are met.</p> <h4>Alert Types:</h4> <ul>     <li><b>downtime:</b> Site becomes unreachable</li>     <li><b>dns_change:</b> DNS records modified</li>     <li><b>whois_change:</b> Registration details updated</li>     <li><b>ssl_expiring:</b> Certificate expires soon (7, 14, 30 days)</li>     <li><b>content_change:</b> Page content modified</li>     <li><b>technology_change:</b> Tech stack changes detected</li> </ul> <h4>Notification Channels:</h4> <ul>     <li>Webhook (POST to your endpoint)</li>     <li>Email</li>     <li>Slack</li>     <li>PagerDuty</li> </ul> <h4>Example Configuration:</h4> <pre><code>{   \"type\": \"ssl_expiring\",   \"threshold_days\": 14,   \"channels\": [\"email\", \"slack\"],   \"email\": \"alerts@example.com\",   \"slack_webhook\": \"https://hooks.slack.com/...\" }</code></pre> 
     * @summary Configure Monitoring Alerts (Asynchronous)
     * @param {string} target The domain or IP address to configure alerts for.
     * @param {object} body Alert configuration including type, thresholds, and notification channels.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createMonitoringAlert(target: string, body: object, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).createMonitoringAlert(target, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Initiates an asynchronous job to capture a screenshot of a website. Supports various viewport sizes, full-page captures, and JavaScript rendering.</p> <p><b>Performance Note:</b> A typical screenshot capture takes 10-30 seconds. Poll the `/v1/ops/jobs/{jobId}` endpoint to retrieve the URL of the final image.</p> <p><b>Output:</b> The job result will contain a URL to download the screenshot image in the specified format (PNG, JPEG, or WebP).</p> 
     * @summary Capture a Website Screenshot (Asynchronous)
     * @param {ScreenshotRequest} screenshotRequest The URL and options for the screenshot capture.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createScreenshot(screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).createScreenshot(screenshotRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves detected changes in infrastructure configuration for a domain or IP over time. Essential for security monitoring and compliance auditing.</p> <h4>Change Types Tracked:</h4> <ul>     <li><b>dns:</b> A, AAAA, MX, NS, TXT record changes</li>     <li><b>whois:</b> Registrant, registrar, nameserver changes</li>     <li><b>ssl:</b> Certificate replacements and expirations</li>     <li><b>ip:</b> IP address changes for domains</li>     <li><b>content:</b> Homepage content modifications</li>     <li><b>technology:</b> Tech stack changes</li> </ul> <h4>Response Format:</h4> <p>Timeline of changes with before/after values:</p> <pre><code>{   \"changes\": [     {       \"timestamp\": \"2025-01-15T10:30:00Z\",       \"type\": \"dns\",       \"field\": \"A_RECORD\",       \"old_value\": \"8.8.8.8\",       \"new_value\": \"1.1.1.1\"     }   ] }</code></pre> <h4>Use Cases:</h4> <ul>     <li>Security incident investigation</li>     <li>Compliance and audit trails</li>     <li>Detecting unauthorized changes</li>     <li>Infrastructure change management</li> </ul> 
     * @summary Get Infrastructure Change History
     * @param {string} target The domain or IP address to check for changes.
     * @param {GetChangeDetectionTypeEnum} [type] Type of changes to retrieve.
     * @param {string} [since] ISO 8601 timestamp to retrieve changes from. Omit to get all changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChangeDetection(target: string, type?: GetChangeDetectionTypeEnum, since?: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).getChangeDetection(target, type, since, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves the current status and results of an asynchronous job. Poll this endpoint to check job progress.</p> <h4>Polling Recommendations:</h4> <ul>     <li>For fast jobs (e.g., similar domains), poll every 1-2 seconds.</li>     <li>For slow jobs (e.g., WHOIS search, screenshots), poll every 5-10 seconds.</li>     <li>Implement an exponential backoff strategy for very long-running jobs.</li>     <li>Stop polling when the status is `COMPLETED`, `FAILED`, or `CANCELLED`.</li> </ul> <h4>Job Statuses:</h4> <ul>     <li><b>PENDING:</b> Job is queued and waiting to start.</li>     <li><b>PROCESSING:</b> Job is actively being processed.</li>     <li><b>COMPLETED:</b> Job finished successfully, results are available.</li>     <li><b>FAILED:</b> Job failed with an error.</li>     <li><b>CANCELLED:</b> Job was cancelled by user or system.</li> </ul> 
     * @summary Get Asynchronous Job Status and Results
     * @param {string} jobId The unique ID of the job, returned from a &#x60;POST&#x60; operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getJob(jobId: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).getJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieves current monitoring configuration and historical metrics for a domain or IP address.</p> <h4>Status Information:</h4> <ul>     <li><b>Monitoring State:</b> Active, paused, or not monitored</li>     <li><b>Check Frequency:</b> How often checks are performed</li>     <li><b>Active Alerts:</b> Currently triggered alert conditions</li>     <li><b>Last Check:</b> Timestamp of most recent check</li> </ul> <h4>Metrics Included:</h4> <ul>     <li>Uptime percentage (last 30 days)</li>     <li>Average response time</li>     <li>SSL certificate expiration countdown</li>     <li>DNS change events</li>     <li>WHOIS change events</li> </ul> 
     * @summary Get Monitoring Status and Metrics
     * @param {string} target The domain or IP address to check monitoring status for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMonitoringStatus(target: string, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).getMonitoringStatus(target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Retrieve all previously captured screenshots for a specific URL, ordered by capture time (newest first). Includes download URLs and metadata for each capture.</p> <h4>Response Includes:</h4> <ul>     <li><b>Download URL:</b> Direct link to screenshot image</li>     <li><b>Capture Time:</b> Timestamp when screenshot was taken</li>     <li><b>Dimensions:</b> Image width and height</li>     <li><b>Format:</b> Image format (PNG, JPEG, WebP)</li>     <li><b>File Size:</b> Size in bytes</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Review website evolution over time</li>     <li>Compare screenshots for change detection</li>     <li>Download historical screenshots for reporting</li> </ul> 
     * @summary Get Screenshot History
     * @param {string} url The URL to retrieve screenshot history for.
     * @param {number} [limit] Maximum number of screenshots to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getScreenshotHistory(url: string, limit?: number, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).getScreenshotHistory(url, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Create a recurring job to capture website screenshots at regular intervals. Essential for monitoring website changes, detecting defacements, and tracking competitor updates.</p> <h4>Schedule Options:</h4> <ul>     <li><b>Cron Expression:</b> Full cron syntax support (e.g., `0 0 * * * *` = hourly)</li>     <li><b>Frequency Presets:</b> hourly, daily, weekly, monthly</li>     <li><b>Timezone:</b> Specify timezone for accurate scheduling</li>     <li><b>Retention:</b> Auto-cleanup old screenshots (default: keep last 30)</li> </ul> <h4>Performance:</h4> <ul>     <li><b>Setup Time:</b> ~2 seconds to create schedule</li>     <li><b>Screenshot Time:</b> 10-30 seconds per capture</li> </ul> <h4>Use Cases:</h4> <ul>     <li>Automated defacement detection</li>     <li>Compliance monitoring and archival</li>     <li>Competitor website tracking</li>     <li>Visual regression testing</li> </ul> 
     * @summary Schedule Recurring Screenshots (Asynchronous)
     * @param {ScreenshotRequest} screenshotRequest Schedule configuration including URL, schedule timing, and screenshot options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scheduleScreenshot(screenshotRequest: ScreenshotRequest, options?: RawAxiosRequestConfig) {
        return OperationsApiFp(this.configuration).scheduleScreenshot(screenshotRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetChangeDetectionTypeEnum = {
    All: 'all',
    Dns: 'dns',
    Whois: 'whois',
    Ssl: 'ssl',
    Ip: 'ip',
    Content: 'content',
    Technology: 'technology'
} as const;
export type GetChangeDetectionTypeEnum = typeof GetChangeDetectionTypeEnum[keyof typeof GetChangeDetectionTypeEnum];


